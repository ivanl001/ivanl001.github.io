{"./":{"url":"./","title":"简介","keywords":"","body":"Only two things in the world can make us deeply shocked in our innermost being: one is the overhead star—shining sky, the other the noble moral standard in mind. ——Immanuel Kant var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/ 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"00-tools/about.html":{"url":"00-tools/about.html","title":"00-工具相关","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/00-tools/about.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"00-tools/01-git/about.html":{"url":"00-tools/01-git/about.html","title":"01-git","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/00-tools/01-git/about.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"00-tools/01-git/01-git基础.html":{"url":"00-tools/01-git/01-git基础.html","title":"01-git基础","keywords":"","body":"1.1.1. rebase是做什么的？1.1.2. 命令行merge分支？1.1.3. git版本回退1.1.4. git 解决冲突1.1.5. git的stash的作用1.1.6. git切换分支1.1.7. tag的作用[toc] 1.1.1. rebase是做什么的？ 1.1.2. 命令行merge分支？ 1.1.3. git版本回退 查看commit日志 git log --pretty=oneline 本地仓库往前回退一个版本 git reset --hard HEAD^ 本地仓库回退到指定版本 git reset --hard 51ece7a6074122fe17e9d7d08ffdb97f2678b461 如果想要重新回到后续版本 git reflog git reset --hard **** 总结 现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 另外git远程仓库回退 # 找到版本号 git log --pretty=oneline # 本地回退到该版本 git reset --hard *** # 强制回退远程仓库到当前版本 git push -f 1.1.4. git 解决冲突 1，git push的时候发现冲突 # git 如果在push的时候发现push不上去，先拉取一次 git pull # 拉取之后会有提示，说文件有冲突， 通过status命令查看有冲突的文件 git status # 然后vim该文件进行修改即可 # 修改完成后,重新把文件进行添加到暂存区，并提交即可 git add . git commit -m 'merge finished' git push 2, git pull拉取的时候发现有冲突 这个和上面的区别是，先commit, 再pull会支流直流并合并 但是先stash然后pull，再然后push，就不会创建支流。 写代码的时候，还未提交，需要拉取远程代码，发现拉取不下来，有冲突 # 先把当前写的代码stash一下 git add . git stash # 再pull的时候就可以了 git pull # 拉取下来后本地文件变成远程文件了，需要使用git stash pop把存储的数据弹出 git stash list git stash pop # 然后会有提示冲突，解决冲突即可 # 解决冲突 git add . git commit -m 'finished(no merge)' git push 1.1.5. git的stash的作用 参考文档： https://blog.csdn.net/ForMyQianDuan/article/details/78750434 https://blog.csdn.net/kindergarten_sir/article/details/109829115 git stash ----将当前工作区和暂存区进度保存 1, 当你正在当前分支修改代码时候，如果当前分支别人修改了东西并提交到远程，但是需要你放弃自己写的东西，调整一下远程上对方的代码的时候，就可以通过stash把自己的代码保存起来，然后pull对方代码，直接调整，push出去的时候，自己写的代码不会push出去。 然后再通过stash pop再恢复自己的代码，接着写。 stash相当于是临时存储自己的临时代码，push到远程的操作不会push当前自己的临时代码 2, 当你在一个分支上创建一个文件，如果直接切到其他分支上，该文件依然会存在。如果stash后就可以避免这种问题 git stash 保存当前工作区和暂存区进度（默认只会保存加入到版本管理的文件，即未被追踪的文件不会存储） git stash 需要在git add之前执行(这个在命令行的时候好像需要先add才能stash有效) 保存 git stash ----将当前工作区和暂存区进度保存 查看保存列表 git stash list ----查看所有保存的记录列表，记录列表前有{序号}可用于删除或取出。 不可重复恢复 git stash pop stash@{序号} ----恢复，{序号}是可选项，不选会全部恢复。恢复后会从git stash list中删除掉被恢复的项。 可重复恢复 git stash apply stash@{序号} ----恢复，{序号}是可选项，不选会全部恢复。恢复后不会从git stash list中删除掉被恢复的项。 删除某项 git stash drop stash@{序号} ----删除git stash list中的某项保存，{序号}是可选项。 删除所有 git stash clear ----删除git stash list中的所有保存。 1.1.6. git切换分支 查看远程分支 git branch -a 查看本地分支 git branch 切换分支 git checkout dev 1.1.7. tag的作用 tag就像是一个里程碑一个标志一个点，branch是一个新的征程一条线； tag是静态的，branch要向前走； 稳定版本备份用tag，新功能多人开发用branch（开发完成后merge到master）。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/00-tools/01-git/01-git基础.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"00-tools/01-git/02-git常用.html":{"url":"00-tools/01-git/02-git常用.html","title":"02-git常用","keywords":"","body":"1.1. git初始化1.2. git同时推送到多个仓库[toc] 1.1. git初始化1.2. git同时推送到多个仓库 1.1. git初始化 git init # 添加推送到远程的地址 git remote add gitee https://gitee.com/ivanl001/nebulas_doc.git git add . git commit -m 'init' # git push gitee git push --set-upsteam gitee master # 从当前分支直接新建分支并切换到新分支上 git checkout -b pages # 推送，并设置推送的分支 git push --set-upstream gitee pages 1.2. git同时推送到多个仓库 --allow-unrelated-histories 有时候提示atal: refusing to merge unrelated histories的时候可以添加参数：--allow-unrelated-histories # 我仓库中默认是github, 为original, 这里再添加gitlab仓库 # 方法1，push的时候需要单独push git remote add gitlab https://gitlab.com/bool_learning/learning_notebook.git # 方法2, push的时候只需要push一次就行 git remote set-url --add origin https://gitlab.com/bool_learning/learning_notebook.git # 推送的时候 # 查看远程仓库 git remote # 查看远程仓库的具体内容 git remote -v git push -u origin git push -u gitlab # 这个命令用于删除现有的git远程仓库 git remote remove gitlab git push -u origin gitlab 从下面remote -v命令可以看出, origin 是默认仓库，如果不指定，会使用这个 git remote set-url --add *是添加默认origin仓库。因为我这里先设置了 git remote add origin https://github.com/ivanl001/ivanl001.github.io.git 然后设置了： git remote set-url --add origin https://gitlab.com/bool_learning/learning_notebook.git 所以origin可以同时push到两个仓库 $ git remote -v github https://github.com/ivanl001/ivanl001.github.io.git (fetch) github https://github.com/ivanl001/ivanl001.github.io.git (push) gitlab https://gitlab.com/bool_learning/learning_notebook.git (fetch) gitlab https://gitlab.com/bool_learning/learning_notebook.git (push) origin https://github.com/ivanl001/ivanl001.github.io.git (fetch) origin https://github.com/ivanl001/ivanl001.github.io.git (push) origin https://gitlab.com/bool_learning/learning_notebook.git (push) git push origin var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/00-tools/01-git/02-git常用.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"00-tools/02-blog/about.html":{"url":"00-tools/02-blog/about.html","title":"02-blog","keywords":"","body":"1.1. github-page + gitbook + travis 自动构建blog手册1.1.1. 1, 创建仓库并开启page功能1.1.2. 2, 初始化项目1.1.3. 3, 项目提交并准备1.1.4. 4, git配置token及gitalk的密钥1.1.5. 5, 最后配置1.1.6. 6, 去travis中重新build1.1.7. 7, 完成[toc] 1.1. github-page + gitbook + travis 自动构建blog手册1.1.1. 1, 创建仓库并开启page功能1.1.2. 2, 初始化项目1.1.3. 3, 项目提交并准备1.1.4. 4, git配置token及gitalk的密钥1.1.5. 5, 最后配置1.1.6. 6, 去travis中重新build1.1.7. 7, 完成 1.1. github-page + gitbook + travis 自动构建blog手册 参考文档： 开启github page功能： https://pages.github.com/ gitbook+github page搭建：https://github.com/riskers/blog/issues/48 gitbook搭建及插件学习等：https://snowdreams1006.github.io/ 1.1.1. 1, 创建仓库并开启page功能 https://pages.github.com/ 1.1.2. 2, 初始化项目 注意：以下配置文件需要根据自己的github的项目做相关部分内容的更改 2.1, clone出项目 git clone https://github.com/ivanl001/ivanl001.github.io.git 2.2, 在项目中添加配置文件等 .gitignore # 忽略本地测试的node模块代码 node_modules # 忽略gitbook本地测试生成的代码 _book # mac忽略文件 .DS_Store README.md 必要的README.md文件, 这个里面是对项目的描述等内容 vim README.md ## README.md ### 这里是项目的说明文档,内容自定义 SUMMARY.md SUMMARY.md : 这个是gitbook的目录文档，通过这个文件进行目录编写 vim SUMMARY.md * [简介](README.md) book.json book.json : 这个是gitbook的配置文件，在里面配置gitbook的基本配置及插件等 mygitalk中配置了proxy，因为默认的gitalk中使用的代理不能用，使用的时候会报错。 vim book.json { \"title\": \"不二技术博客\", \"author\": \"不二\", \"description\": \"不二 搭建的 Gitbook 个人博客\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"links\": { \"sidebar\": { \"github\": \"https://github.com/ivanl001\", \"gitlab\":\"https://gitlab.com/ivanl001\", \"gitee\":\"https://gitee.com/ivanl001\" } }, \"plugins\": [ \"toc\", \"-lunr\", \"-search\", \"search-plus\", \"splitter\", \"-sharing\", \"sharing-plus\", \"expandable-chapters-small\", \"anchor-navigation-ex\", \"edit-link-plus\", \"code\", \"chart\", \"favicon-absolute\", \"github-buttons\", \"advanced-emoji\", \"sitemap-general\", \"copyright\", \"tbfed-pagefooter\", \"mygitalk\", \"donate\", \"icp\", \"diff\", \"simple-mind-map\", \"hide-element\", \"audio_image\", \"mermaid-gb3\", \"baidu-tongji-with-multiple-channel\", \"google-tongji-with-multiple-channel\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"./pic/wechatpay.jpg\", \"alipay\": \"./pic/alipay.jpg\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝\", \"wechatText\": \"微信\" }, \"favicon-absolute\": { \"favicon\": \"./pic/favicon.ico\", \"appleTouchIconPrecomposed152\": \"./pic/apple-touch-icon-precomposed-152.png\" }, \"toc\": { \"addClass\": true, \"className\": \"toc\" }, \"copyright\": { \"site\": \"https://ivanl001.github.io\", \"author\": \"不二\", \"website\": \"不二技术博客\", \"image\": \"\", \"copyProtect\": true }, \"github-buttons\": { \"buttons\": [{ \"user\": \"ivanl001\", \"repo\": \"ivanl001.github.io.git\", \"type\": \"star\", \"size\": \"small\" }] }, \"tbfed-pagefooter\": { \"copyright\": \"&copy 不二\", \"modify_label\": \"文件修订时间: \", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": true, \"qzone\": true, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\", \"linkedin\", \"pocket\", \"stumbleupon\" ] }, \"edit-link-plus\": { \"base\": { \"ivanl001.github.io\":\"https://github.com/ivanl001/ivanl001.github.io/edit/master\", \"ivanl001.gitlab.io\":\"https://gitlab.com/ivanl001/ivanl001.gitlab.io/edit/master\", \"ivanl001.gitee.io\":\"\" }, \"defaultBase\": \"https://github.com/ivanl001/ivanl001.github.io/edit/master\", \"label\": \"编辑本页\" }, \"chart\": { \"type\": \"c3\" }, \"sitemap-general\": { \"prefix\": \"https://ivanl001.github.io/\" }, \"mygitalk\": { \"clientID\": \"3d8b5499512dfc769dcc\", \"clientSecret\": \"72387e663a746fd79685ed71a74a99e0c27ba530\", \"repo\": \"ivanl001.github.io\", \"owner\": \"ivanl001\", \"admin\": [\"ivanl001\"], \"distractionFreeMode\": false, \"proxy\": \"https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token\" }, \"icp\": { \"number\": \"沪ICP备00000000号(无)\", \"link\": \"http://www.beian.gov.cn/\" }, \"hide-element\": { \"elements\": [\"a.gitbook-link[href='https://www.gitbook.com']\"] }, \"simple-mind-map\":{ \"preset\": \"colorful\" } } } .travis.yml .travis.yml : travis的自动部署配置文件 vim .travis.yml language: node_js node_js: - \"10\" cache: npm notifications: email: recipients: - ivanl001@163.com # 设置通知邮件 on_success: change on_failure: always install: - npm install -g gitbook-cli - gitbook install script: - gitbook build after_script: - cd _book - git init - git remote add origin https://${REF} - git add . - git commit -m \"Updated By Travis-CI With Build $TRAVIS_BUILD_NUMBER For Github Pages\" - git push --force --quiet \"https://${TOKEN}@${REF}\" master:pages branches: only: - master env: global: - REF=github.com/ivanl001/ivanl001.github.io.git # 设置 github 地址 1.1.3. 3, 项目提交并准备 3.1, 提交项目到master分支 git add . git commit -m 'github page + gitbook + travis项目初始化' git push 3.2, 创建pages分支提交gitbook生成静态网页 # 当前分支生成pages分支 git checkout -b pages git add . git commit -m 'branch page created' git push --set-upstream origin pages 3.3, github配置pages分支为github page分支 1.1.4. 4, git配置token及gitalk的密钥 4.1, token(给travis提交代码用) 4.2, client_id 及secret key(给gitalk用) 1.1.5. 5, 最后配置 https://travis-ci.com/ 5.1, 配置git的token方便提交代码到github pages分支 5.2, 回到book.json中修改mygitalk的配置client_id和secret key \"mygitalk\": { \"clientID\": \"3d8b5499512dfc769dcc\", \"clientSecret\": \"72387e663a746fd79685ed71a74a99e0c27ba530\", \"repo\": \"ivanl001.github.io\", \"owner\": \"ivanl001\", \"admin\": [\"ivanl001\"], \"distractionFreeMode\": false, \"proxy\": \"https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token\" } 1.1.6. 6, 去travis中重新build 查看日志，如无问题，则代表ok 进入页面验证是否ok: https://ivanl001.github.io/ 1.1.7. 7, 完成 下次提交代码, travis中会自动构建并提交静态网页到pages分支 end end end var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/00-tools/02-blog/about.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/about.html":{"url":"01-algthrim/about.html","title":"算法","keywords":"","body":"1.1.1. 2021-04-10 开始00-算法基础学习[toc] 1.1.1. 2021-04-10 开始00-算法基础学习 1.1.1. 2021-04-10 开始00-算法基础学习 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/about.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/01-basic/about.html":{"url":"01-algthrim/01-basic/about.html","title":"01-算法基础","keywords":"","body":"1.1. 学习进度1.1.1. 2021-04-10[toc] 1.1. 学习进度1.1.1. 2021-04-10 1.1. 学习进度 主要是基础算法相关的内容 1.1.1. 2021-04-10 2021-04-10 先开始从leetcode刷新开始 2021-04-24 开始复习韩顺平老师的数据结构和算法内容，笔记内容：02-韩顺平老师数据结构与算法 2021-05-23 周日-基本看完韩顺平的教程，对于数据结构和算法有了基础的了解 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/01-basic/about.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/01-basic/01-leetcode刷题.html":{"url":"01-algthrim/01-basic/01-leetcode刷题.html","title":"01-leecode刷题","keywords":"","body":"[toc] 7. 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 我的答案 // 没想出来怎么把余数加和，看了答案 官方答案 public int reverse_v1(int x) { int rev = 0; while (x != 0) { int pop = x%10; x /= 10; /*if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) { return 0; } if (rev 214748364 || (rev==214748364 && pop>7)) { return 0; } //判断是否 小于 最小32位整数 if (rev 5. 最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串。 我的答案 答案应该没错，但是因为是暴力遍历，效率低，超出了时间限制 /** * 我的答案： * 暴力解法(这个方法不太好，1，直接使用字符串的方法，效率低，最好把字符串转化成数组，方便直接获取) * @param s * @return */ public String longestPalindrome_v0(String s) { int n = s.length(); if (n == 1) { System.out.println(\"答案是:\" + s); return s; } int rk; StringBuilder tmpAns; String answer = \"\"; for (int i = 0; i = 0; m--) { reversed.append(words.charAt(m)); } if (tmpAns.toString().equals(reversed.toString())) { if (answer.length() 官方答案1： 暴力解法 官方的暴力解法 /** * 官方的暴力解法 * @param s * @return */ public String longestPalindrome_v0(String s) { int length = s.length(); // 小于2的时候，本身就是回文串，直接返回即可 if (length (endIndex-startIndex))) { startIndex = i; endIndex = j; } } } // substring是前包后不包的 System.out.println(\"结果是：\" + s.substring(startIndex, endIndex+1)); return s.substring(startIndex, endIndex+1); } 官方答案2: 中心扩散法 从内向外 // 暂时未总结，看答案 官方答案3: 动态规划 从外向内 /** * 官方的动态规划解法 * 从外部往内部循环 * * 时间复杂度:O(n^2) * 空间复杂度:O(n^2) * @param s * @return */ public String longestPalindrome_v3(String s) { int length = s.length(); // 小于2的时候，本身就是回文串，直接返回即可 if (length maxLen) { // 因为字符串的subString是前包后不包的，所以需要加1 maxLen = j - i + 1; begin = i; } } } return s.substring(begin, begin + maxLen); } 官方答案4: manacher解法 // 暂时看不懂，后面再看 3. 无重复字符的最长子串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 我的答案 这里没答对，只考虑了直线，没考虑窗口，而且效率不行。 /** * 如果是相对较短的话， 还可以， 但是如果是较长的字符串，效果不太好，会超时。 * @param s * @return */ public int lengthOfLongestSubstring_v0(String s) { int maxLeng = 0; for (int m = 0; m data = new HashMap<>(); Map charData = new HashMap<>(); // 这个地方刚开始是用0，后来看了官方答案是用m合适点 for (int i = m; i maxLeng) { maxLeng = charData.size(); } } else { if (charData.size() > maxLeng) { maxLeng = charData.size(); } charData.clear(); } charData.put(String.valueOf(chars[i]), i); } if (charData.size() > maxLeng) { maxLeng = charData.size(); } if (chars.length == 1 && maxLeng 官方答案 /** * 官方的解题方法 * @param s * @return */ public int lengthOfLongestSubstring_v1(String s) { // 哈希集合，记录每个字符是否出现过 Set occ = new HashSet(); int n = s.length(); // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 int rk = -1, ans = 0; for (int i = 0; i 我看了官方答案优化的一版 public int lengthOfLongestSubstring_v2(String s) { // 哈希集合，记录每个字符是否出现过 Set occ = new HashSet(); int n = s.length(); // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 int rk = -1, ans = 0; for (int i = 0; i 2. 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 我的答案 暂时还有问题，还需要调整 /** * 这里还有bug，输入两个5，会有问题 * @param l1 * @param l2 * @return */ // TODO: 这里还有问题：输入两个5，会有问题 public ListNode addTwoNumbers_v0(ListNode l1, ListNode l2) { // 先判断长度 int l1Length = 1; ListNode current1 = l1; while (current1.next != null) { l1Length += 1; current1 = current1.next; } System.out.println(\"l1的长度是:\" + l1Length); int l2Length = 1; ListNode current2 = l2; while (current2.next != null) { l2Length += 1; current2 = current2.next; } System.out.println(\"l2的长度是:\" + l2Length); boolean tenPlus = false; ListNode current ; if (l1Length >= l2Length) { current = l1; int tenPlusNum = 0; int i=0; while (current.next != null) { System.out.println(i++); if (tenPlus) { tenPlusNum = 1; } tenPlus = (current.val + l2.val + tenPlusNum) >= 10; current.val = (current.val + l2.val + tenPlusNum)%10 ; current = current.next; l2 = l2.next == null ? new ListNode(0, null) : l2.next; } if (tenPlus) { tenPlusNum = 1; if (current.val + l2.val + tenPlusNum >= 10) { current.next = new ListNode(1, null); } current.val = (current.val + l2.val + tenPlusNum)%10; } else { current.val = current.val + l2.val; } return l1; } else { current = l2; int tenPlusNum = 0; int i=0; while (current.next != null) { System.out.println(i++); if (tenPlus) { tenPlusNum = 1; } tenPlus = (current.val + l1.val + tenPlusNum) >= 10; current.val = (current.val + l1.val + tenPlusNum)%10 ; current = current.next; l1 = l1.next == null ? new ListNode(0, null) : l1.next; } if (tenPlus) { tenPlusNum = 1; if (current.val + l1.val + tenPlusNum >= 10) { current.next = new ListNode(1, null); } current.val = (current.val + l1.val + tenPlusNum)%10; } else { current.val = current.val + l1.val; } return l2; } } 官方答案 /** * 官方解题方法 * @param l1 * @param l2 * @return */ public ListNode addTwoNumbers_v1(ListNode l1, ListNode l2) { ListNode head = null, tail = null; // 进位为0 int carry = 0; while (l1 != null || l2 != null) { int n1 = l1 == null ? 0 : l1.val; int n2 = l2 == null ? 0 : l2.val; int sum = n1 + n2 + carry; if (head == null) { head = tail = new ListNode(sum%10); } else { tail.next = new ListNode(sum%10); tail = tail.next; } carry = sum/10; if (l1 != null) { l1 = l1.next; } if (l2 != null) { l2 = l2.next; } } // carry最大应该只能为1吧 if (carry > 0) { tail.next = new ListNode(carry); } return head; } 更好的答案 /** * https://leetcode-cn.com/problems/add-two-numbers/solution/ji-bai-100di-gui-jie-fa-shuai-zha-by-tan-vzaj/ * @param l1 * @param l2 * @return * 这个算法确实非常巧妙， 把整体加和分散到单个位数加和。通过迭代实现单个位数加和 */ public ListNode addTwoNumbers_v3(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } if (l2 == null) { return l1; } // 直接修改l2，最后返回l2 l2.val = l1.val + l2.val; if (l2.val >= 10) { l2.val = l2.val % 10; if (l2.next != null) { l2.next.val = l2.next.val + 1; if (l2.next.val == 10) { l2.next = addTwoNumbers_v3(new ListNode(0, null), l2.next); } } else { l2.next = new ListNode(1, null); } } l2.next = addTwoNumbers_v3(l1.next, l2.next); return l2; } 1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 我的答案 /** * 我的答案： * 暴力解法， 两次遍历，直接找数据即可 * @param nums * @param target * @return */ public int[] twoSum_v0(int[] nums, int target) { int diff; int[] arr = new int[2]; for (int i=0;i 官方答案 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1) 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 /** * 官方答案: * 一次遍历， 遍历之前， 先准备一个hashtable，遍历时候把数据存储进去， 直接从这里找对应的值即可。这样不用第二次遍历 * * 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。 * * 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1) * * 作者：LeetCode-Solution * 链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * @param nums * @param target * @return */ public int[] twoSum_v1(int[] nums, int target) { Map hashtable = new HashMap<>(); int diff; for (int i = 0; i 值得思考的问题： 对于官方第二种采用哈希表的方法，其效率应该是低于采用双循环数组的方式，因为数组遍历的效率大于HashMap，做一个测试： public void findOne(int key) { int size = 1000 * 10000; int[] arr = new int[size]; Map map = new HashMap<>(size); for (int i=0;i 思考： 用了containsValue， 而不是containKey 如果查找的数字在数组的最前面， 那确实是数组快点，如果是在后面，还是hashmap快一点 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/01-basic/01-leetcode刷题.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/02-hanshunping/about.html":{"url":"01-algthrim/02-hanshunping/about.html","title":"02-韩顺平教程","keywords":"","body":" 该教程所有内容均为参考学习韩顺平老师的教程 如下为youtube视频教程链接 【韩顺平】图解Java数据结构和算法 2021-04-24 周六 复习了之前学习的教程 2021-05-23 周日 基本完成了韩顺平的教程 课程 第一遍 第二遍 001-尚硅谷-老韩图解Java数据结构和算法-几个经典的算法面试题(1).avi 1 1 002-尚硅谷-老韩图解Java数据结构和算法-几个经典的算法面试题(2).avi 1 1 003-尚硅谷-老韩图解Java数据结构和算法-内容介绍和授课方式.avi 1 1 004-尚硅谷-老韩图解Java数据结构和算法-数据结构和算法的关系.avi 1 1 005-尚硅谷-老韩图解Java数据结构和算法-编程中实际遇到的几个问题.avi 1 1 006-尚硅谷-老韩图解Java数据结构和算法-线性结构和非线性结构.avi 1 1 007-尚硅谷-老韩图解Java数据结构和算法-稀疏数组的应用场景.avi 1 1 008-尚硅谷-老韩图解Java数据结构和算法-稀疏数组转换的思路分析.avi 1 1 009-尚硅谷-老韩图解Java数据结构和算法-稀疏数组的代码实现.avi 1 1 010-尚硅谷-老韩图解Java数据结构和算法-队列的应用场景和介绍.avi 1 1 011-尚硅谷-老韩图解Java数据结构和算法-数组模拟队列的思路分析.avi 1 1 012-尚硅谷-老韩图解Java数据结构和算法-数组模拟队列代码实现(1).avi 1 1 013-尚硅谷-老韩图解Java数据结构和算法-数组模拟队列代码实现(2).avi 1 1 014-尚硅谷-老韩图解Java数据结构和算法-数组模拟环形队列思路分析图.avi 1 1 015-尚硅谷-老韩图解Java数据结构和算法-数组模拟环形队列实现.avi 1 1 016-尚硅谷-老韩图解Java数据结构和算法-单链表介绍和内存布局.avi 1 1 017-老韩图解Java数据结构和算法-单链表创建和遍历的分析实现.avi 1 1 018-尚硅谷-老韩图解Java数据结构和算法-单链表按顺序插入节点.avi 1 1 019-尚硅谷-老韩图解Java数据结构和算法-单链表节点的修改.avi 1 1 020-尚硅谷-老韩图解Java数据结构和算法-单链表节点的删除和小结.avi 1 1 021-尚硅谷-老韩图解Java数据结构和算法-单链表新浪面试题.avi 1 1 022-尚硅谷-老韩图解Java数据结构和算法-单链表腾讯面试题.avi 1 1 023-尚硅谷-老韩图解Java数据结构和算法-单链表百度面试题.avi 1 1 024-尚硅谷-老韩图解Java数据结构和算法-双向链表增删改查分析图解.avi 1 1 025-尚硅谷-老韩图解Java数据结构和算法-双向链表增删改查代码实现.avi 1 1 026-尚硅谷-老韩图解Java数据结构和算法-双向链表功能测试和小结.avi 1 1 027-尚硅谷-老韩图解Java数据结构和算法-环形链表介绍和约瑟夫问题.avi 1 1 028-尚硅谷-老韩图解Java数据结构和算法-约瑟夫问题分析图解和实现(1).avi 1 1 029-尚硅谷-老韩图解Java数据结构和算法-约瑟夫问题分析图解和实现(2).avi 1 1 030-尚硅谷-老韩图解Java数据结构和算法-栈的应用场景和介绍.avi 1 1 031-尚硅谷-老韩图解Java数据结构和算法-栈的思路分析和代码实现.avi 1 1 032-尚硅谷-老韩图解Java数据结构和算法-栈的功能测试和小结.avi 1 1 033-尚硅谷-老韩图解Java数据结构和算法-栈实现综合计算器-思路分析(1).avi 1 034-尚硅谷-老韩图解Java数据结构和算法-栈实现综合计算器-代码实现(2).avi 1 035-尚硅谷-老韩图解Java数据结构和算法-栈实现综合计算器-代码实现(3).avi 1 036-尚硅谷-老韩图解Java数据结构和算法-前缀 中缀 后缀表达式规则.avi 1 037-尚硅谷-老韩图解Java数据结构和算法-逆波兰计算器分析和实现(1).avi 1 038-尚硅谷-老韩图解Java数据结构和算法-逆波兰计算器分析和实现(2).avi 1 039-尚硅谷-老韩图解Java数据结构和算法-中缀转后缀表达式思路分析.avi 1 040-尚硅谷-老韩图解Java数据结构和算法-中缀转后缀表达式代码实现(1).avi 1 041-尚硅谷-老韩图解Java数据结构和算法-中缀转后缀表达式代码实现(2).avi 1 042-尚硅谷-老韩图解Java数据结构和算法-完整版逆波兰计算器和小结.avi 1 043-尚硅谷-老韩图解Java数据结构和算法-递归应用场景和调用机制.avi 1 1 044-尚硅谷-老韩图解Java数据结构和算法-递归能解决的问题和规则.avi 1 1 045-尚硅谷-老韩图解Java数据结构和算法-迷宫回溯问题分析和实现(1).avi 1 1 046-尚硅谷-老韩图解Java数据结构和算法-迷宫回溯问题分析和实现(2).avi 1 1 047-尚硅谷-老韩图解Java数据结构和算法-八皇后问题分析和实现(1).avi 1 1 048-尚硅谷-老韩图解Java数据结构和算法-八皇后问题分析和实现(2).avi 1 1 049-尚硅谷-老韩图解Java数据结构和算法-八皇后问题分析和实现(3).avi 1 1 050-尚硅谷-老韩图解Java数据结构和算法-排序算法介绍和分类.avi 1 1 051-尚硅谷-老韩图解Java数据结构和算法-时间频度介绍和特点.avi 1 1 052-尚硅谷-老韩图解Java数据结构和算法-时间复杂度计算和举例说明.avi 1 1 053-尚硅谷-老韩图解Java数据结构和算法-平均和最坏时间复杂度介绍.avi 1 1 054-尚硅谷-老韩图解Java数据结构和算法-冒泡排序算法思路图解.avi 1 1 055-尚硅谷-老韩图解Java数据结构和算法-冒泡排序算法代码实现.avi 1 1 056-尚硅谷-老韩图解Java数据结构和算法-冒泡排序算法优化和总结.avi 1 1 057-尚硅谷-老韩图解Java数据结构和算法-选择排序算法思路图解.avi 1 1 058-尚硅谷-老韩图解Java数据结构和算法-选择排序算法代码实现.avi 1 1 059-尚硅谷-老韩图解Java数据结构和算法-选择排序算法速度测试.avi 1 1 060-尚硅谷-老韩图解Java数据结构和算法-插入排序算法思路图解.avi 1 1 061-尚硅谷-老韩图解Java数据结构和算法-插入排序算法代码实现.avi 1 1 062-尚硅谷-老韩图解Java数据结构和算法-插入排序算法速度测试.avi 1 1 063-尚硅谷-老韩图解Java数据结构和算法-希尔排序算法思路图解.avi 1 1 064-尚硅谷-老韩图解Java数据结构和算法-希尔排序[交换式]算法实现.avi 1 1 065-尚硅谷-老韩图解Java数据结构和算法-希尔排序[移位式]算法实现.avi 1 1 066-尚硅谷-老韩图解Java数据结构和算法-快速排序算法思路图解.avi 1 1 067-尚硅谷-老韩图解Java数据结构和算法-快速排序算法代码实现.avi 1 1 068-尚硅谷-老韩图解Java数据结构和算法-快速排序算法速度测试.avi 1 1 069-尚硅谷-老韩图解Java数据结构和算法-归并排序算法思路图解.avi 1 1 070-尚硅谷-老韩图解Java数据结构和算法-归并排序算法代码实现.avi 1 1 071-尚硅谷-老韩图解Java数据结构和算法-归并排序算法速度测试.avi 1 1 072-尚硅谷-老韩图解Java数据结构和算法-基数排序算法思路图解.avi 1 1 073-尚硅谷-老韩图解Java数据结构和算法-基数排序算法代码实现(1).avi 1 1 074-尚硅谷-老韩图解Java数据结构和算法-基数排序算法代码实现(2).avi 1 1 075-尚硅谷-老韩图解Java数据结构和算法-基数排序算法注意事项.avi 1 1 076-尚硅谷-老韩图解Java数据结构和算法-排序算法时间复杂度比较.avi 1 1 077-尚硅谷-老韩图解Java数据结构和算法-线性查找分析和实现.avi 1 1 078-尚硅谷-老韩图解Java数据结构和算法-二分查找算法思路图解.avi 1 1 079-尚硅谷-老韩图解Java数据结构和算法-二分查找算法代码实现.avi 1 1 080-尚硅谷-老韩图解Java数据结构和算法-二分查找算法功能完善.avi 1 1 081-尚硅谷-老韩图解Java数据结构和算法-插值查找算法工作原理.avi 1 1 082-尚硅谷-老韩图解Java数据结构和算法-插值查找算法代码实现.avi 1 1 083-尚硅谷-老韩图解Java数据结构和算法-斐波那契查找算法原理.avi 1 1 084-尚硅谷-老韩图解Java数据结构和算法-斐波那契查找代码实现.avi 1 1 085-尚硅谷-老韩图解Java数据结构和算法-斐波那契查找算法小结.avi 1 1 086-尚硅谷-老韩图解Java数据结构和算法-哈希表的介绍和内存布局.avi 1 1 087-尚硅谷-老韩图解Java数据结构和算法-哈希表实现思路图解.avi 1 1 088-尚硅谷-老韩图解Java数据结构和算法-哈希表代码实现(1).avi 1 1 089-尚硅谷-老韩图解Java数据结构和算法-哈希表代码实现(2).avi 1 1 090-尚硅谷-老韩图解Java数据结构和算法-数组 链表 树存储方式分析.avi 1 1 091-尚硅谷-老韩图解Java数据结构和算法-二叉树的概念和常用术语.avi 1 1 092-尚硅谷-老韩图解Java数据结构和算法-前序中序后序遍历二叉树图解.avi 1 1 093-尚硅谷-老韩图解Java数据结构和算法-前序中序后序遍历代码实现(1).avi 1 1 094-尚硅谷-老韩图解Java数据结构和算法-前序中序后序遍历代码实现(2).avi 1 1 095-尚硅谷-老韩图解Java数据结构和算法-前序中序后序查找思路图解.avi 1 1 096-尚硅谷-老韩图解Java数据结构和算法-前序中序后序查找代码实现(1).avi 1 1 097-尚硅谷-老韩图解Java数据结构和算法-前序中序后序查找代码实现(2).avi 1 1 098-尚硅谷-老韩图解Java数据结构和算法-二叉树删除结点思路图解.avi 1 1 099-尚硅谷-老韩图解Java数据结构和算法-二叉树删除结点代码实现.avi 1 1 100-尚硅谷-老韩图解Java数据结构和算法-顺序存储二叉树思路图解.avi 1 1 101-尚硅谷-老韩图解Java数据结构和算法-顺序存储二叉树代码实现.avi 1 1 102-尚硅谷-老韩图解Java数据结构和算法-线索化二叉树的介绍.avi 1 1 103-尚硅谷-老韩图解Java数据结构和算法-线索化二叉树思路图解.avi 1 1 104-尚硅谷-老韩图解Java数据结构和算法-线索化二叉树代码实现1.avi 1 1 105-尚硅谷-老韩图解Java数据结构和算法-线索化二叉树代码实现2.avi 1 1 106-尚硅谷-老韩图解Java数据结构和算法-遍历线索化二叉树实现.avi 1 107-尚硅谷-老韩图解Java数据结构和算法-大顶堆和小顶堆图解说明.avi 1 108-尚硅谷-老韩图解Java数据结构和算法-堆排序的思路图解.avi 1 109-尚硅谷-老韩图解Java数据结构和算法-堆排序的代码实现1.avi -1(听不懂了) --1(懂了) 110-尚硅谷-老韩图解Java数据结构和算法-堆排序的代码实现2.avi -1(听不懂了)--1(懂了) 111-尚硅谷-老韩图解Java数据结构和算法-堆排序的速度测试和小结.avi 1 112-尚硅谷-老韩图解Java数据结构和算法-赫夫曼树的基本介绍.avi 1 113-尚硅谷-老韩图解Java数据结构和算法-赫夫曼树创建步骤图解.avi 1 114-尚硅谷-老韩图解Java数据结构和算法-赫夫曼树创建代码实现.avi 1 115-尚硅谷-老韩图解Java数据结构和算法-变长编码的举例说明.avi 1 116-尚硅谷-老韩图解Java数据结构和算法-赫夫曼编码的原理图解.avi 1 117-尚硅谷-老韩图解Java数据结构和算法-数据压缩-创建赫夫曼树思路.avi 1 118-尚硅谷-老韩图解Java数据结构和算法-数据压缩-创建赫夫曼树实现.avi 1 119-尚硅谷-老韩图解Java数据结构和算法-数据压缩-生成赫夫曼编码表.avi 1 120-尚硅谷-老韩图解Java数据结构和算法-数据压缩-赫夫曼编码字节数组.avi 1 121-尚硅谷-老韩图解Java数据结构和算法-数据压缩-赫夫曼字节数组封装.avi 1 122-尚硅谷-老韩图解Java数据结构和算法-数据解压-字节转二进制字符串.avi 1 123-尚硅谷-老韩图解Java数据结构和算法-数据解压-赫夫曼解码.avi 1 124-尚硅谷-老韩图解Java数据结构和算法-使用赫夫曼编码压缩文件.avi 1 125-尚硅谷-老韩图解Java数据结构和算法-使用赫夫曼编码解压文件.avi 1 126-尚硅谷-老韩图解Java数据结构和算法-赫夫曼编码注意事项.avi 1 127-尚硅谷-老韩图解Java数据结构和算法-二叉排序树(BST)的介绍.avi 1BST(Binary Sort Tree) 128-尚硅谷-老韩图解Java数据结构和算法-二叉排序树(BST)创建和遍历.avi 1 129-尚硅谷-老韩图解Java数据结构和算法-二叉排序树删除结点思路图解.avi 1 130-尚硅谷-老韩图解Java数据结构和算法-二叉排序树删除叶子结点(1).avi 1 131-尚硅谷-老韩图解Java数据结构和算法-二叉排序树删除叶子结点(2).avi 1 132-尚硅谷-老韩图解Java数据结构和算法-BST删除有一颗子树的结点.avi 1 133-尚硅谷-老韩图解Java数据结构和算法-BST删除有二颗子树的结点.avi 1 134-尚硅谷-老韩图解Java数据结构和算法-BST删除结点的注意事项.avi 1 135-尚硅谷-老韩图解Java数据结构和算法-平衡二叉树(AVL树)介绍.avi 1 136-尚硅谷-老韩图解Java数据结构和算法-AVL树左旋转思路图解.avi 1 137-尚硅谷-老韩图解Java数据结构和算法-AVL树高度求解.avi 1 138-尚硅谷-老韩图解Java数据结构和算法-AVL树左旋转代码实现.avi 1 139-尚硅谷-老韩图解Java数据结构和算法-AVL树右旋转图解和实现.avi 1 140-尚硅谷-老韩图解Java数据结构和算法-AVL树双旋转图解和实现.avi 1 141-尚硅谷-老韩图解Java数据结构和算法-平衡二叉树(AVL树)小结.avi 1 143-尚硅谷-老韩图解Java数据结构和算法-2-3树原理图解.avi 1 144-尚硅谷-老韩图解Java数据结构和算法-B树和B加树原理图解.avi 1 145-尚硅谷-老韩图解Java数据结构和算法-B星树和多路查找树小结.avi 1 146-尚硅谷-老韩图解Java数据结构和算法-图的基本介绍和存储形式.avi 1 147-尚硅谷-老韩图解Java数据结构和算法-图的创建图解和代码实现.avi 1 148-尚硅谷-老韩图解Java数据结构和算法-图的深度优先(DFS)算法图解.avi 1 149-尚硅谷-老韩图解Java数据结构和算法-图的深度优先(DFS)代码实现.avi 1 150-尚硅谷-老韩图解Java数据结构和算法-图的广度优先(BFS)算法图解.avi 1 151-尚硅谷-老韩图解Java数据结构和算法-图的广度优先(BFS)代码实现.avi 1 152-尚硅谷-老韩图解Java数据结构和算法-DFS和BFS比较及图小结.avi 1 153-尚硅谷-老韩图解Java数据结构和算法-二分查找非递归算法分析实现.avi 1 154-尚硅谷-老韩图解Java数据结构和算法-分治算法的设计模式.avi 1 155-尚硅谷-老韩图解Java数据结构和算法-分治算法解决汉诺塔问题.avi 1 156-尚硅谷-老韩图解Java数据结构和算法-动态规划算法基本介绍.avi 1 157-尚硅谷-老韩图解Java数据结构和算法-动态规划算法解决背包问题1.avi 1 158-尚硅谷-老韩图解Java数据结构和算法-动态规划算法解决背包问题2.avi 1 159-尚硅谷-老韩图解Java数据结构和算法-动态规划算法解决背包问题3.avi 1 160-尚硅谷-老韩图解Java数据结构和算法-暴力匹配算法解决字串匹配问题.avi 1 161-尚硅谷-老韩图解Java数据结构和算法-KMP算法解决字串匹配思路图解.avi 1 162-尚硅谷-老韩图解Java数据结构和算法-KMP算法解决字串匹配代码实现.avi 1kmp算法并未听懂。。。 163-尚硅谷-老韩图解Java数据结构和算法-动态规划算法和KMP算法小结.avi 1 164-尚硅谷-老韩图解Java数据结构和算法-贪心算法的基本介绍.avi 1 165-尚硅谷-老韩图解Java数据结构和算法-贪心算法解决集合覆盖思路图解.avi 166-尚硅谷-老韩图解Java数据结构和算法-贪心算法解决集合覆盖代码实现.avi 167-尚硅谷-老韩图解Java数据结构和算法-贪心算法解决集合覆盖注意事项.avi 168-尚硅谷-老韩图解Java数据结构和算法-普利姆算法(Prim)和MST介绍.avi 169-尚硅谷-老韩图解Java数据结构和算法-Prim算法解决修路问题思路图解.avi 170-尚硅谷-老韩图解Java数据结构和算法-Prim算法解决修路问题生成图.avi 171-尚硅谷-老韩图解Java数据结构和算法-Prim算法解决修路问题代码实现.avi 172-尚硅谷-老韩图解Java数据结构和算法-克鲁斯卡尔((Kruskal)算法图解.avi 173-尚硅谷-老韩图解Java数据结构和算法-Kruskal算法解决公交问题(1).avi 174-尚硅谷-老韩图解Java数据结构和算法-Kruskal算法解决公交问题(2).avi 175-尚硅谷-老韩图解Java数据结构和算法-Kruskal算法解决公交问题(3).avi 176-尚硅谷-老韩图解Java数据结构和算法-Kruskal算法解决公交问题(4).avi 177-尚硅谷-老韩图解Java数据结构和算法-Kruskal算法解决公交问题小结.avi 178-尚硅谷-老韩图解Java数据结构和算法-迪杰斯特拉(Dijkstra)算法基本介绍.avi 179-尚硅谷-老韩图解Java数据结构和算法-Dijkstra算法思路图解.avi 180-尚硅谷-老韩图解Java数据结构和算法-Dijkstra算法解决最短路径问题(1).avi 181-尚硅谷-老韩图解Java数据结构和算法-Dijkstra算法解决最短路径问题(2).avi 182-尚硅谷-老韩图解Java数据结构和算法-Dijkstra算法解决最短路径问题(3).avi 183-尚硅谷-老韩图解Java数据结构和算法-Dijkstra算法解决最短路径问题(4).avi 184-尚硅谷-老韩图解Java数据结构和算法-Dijkstra算法解决最短路径问题(5).avi 185-尚硅谷-老韩图解Java数据结构和算法-弗洛伊德(Floyd)算法基本介绍.avi 186-尚硅谷-老韩图解Java数据结构和算法-弗洛伊德(Floyd)算法思路图解.avi 187-尚硅谷-老韩图解Java数据结构和算法-Floyd算法解决最短路径问题(1).avi 188-尚硅谷-老韩图解Java数据结构和算法-Floyd算法解决最短路径问题(2).avi 189-尚硅谷-老韩图解Java数据结构和算法-骑士周游问题和游戏说明.avi 190-尚硅谷-老韩图解Java数据结构和算法-骑士周游问题思路图解.avi 191-尚硅谷-老韩图解Java数据结构和算法-骑士周游回溯算法代码实现(1).avi 192-尚硅谷-老韩图解Java数据结构和算法-骑士周游回溯算法代码实现(2).avi 193-尚硅谷-老韩图解Java数据结构和算法-骑士周游回溯算法代码实现(3).avi 194-尚硅谷-老韩图解Java数据结构和算法-骑士周游回溯算法用贪心算法优化.avi 195-尚硅谷-老韩图解Java数据结构和算法-结束语(卖油翁和老黄牛).avi 1 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/02-hanshunping/about.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/02-hanshunping/01-数据结构-01-线形数据结构.html":{"url":"01-algthrim/02-hanshunping/01-数据结构-01-线形数据结构.html","title":"01-数据结构-01-线形数据结构","keywords":"","body":"1.1. 数据结构1.1.1. 1, 线性结构[toc] 1.1. 数据结构1.1.1. 1, 线性结构 1.1. 数据结构 数据结构是算法的基础 数据结构分为线性结构和非线性结构 1.1.1. 1, 线性结构 线性结构作为最常用的数据结构，其特点是数据元素之间存在==一对一==的线性关系 线性结构常见的有：==数组==、==队列==、==链表==和==栈==， 线性结构有两种不同的存储结构，即==顺序存储结构(包括数组队列栈)==和==链式存储结构(包括)==。 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息 1.1, 数组 稀疏数组(sparseArray) 稀疏数组其实是一个二维数组，这里放在线性结构的数组里面并不合适。所以放入非线性结构的二维数组中记录 1.2, 队列 队列是一个有序列表， 可以用数组(顺序存储)或链表(链式存储)实现， 队列的原则： FIFO先进先出 单向队列 数组模拟简单队列 下图默认索引从-1开始， 我们代码中使用0开始 数组模拟的队列会有队列容量限制，一旦超过指定数量就不能进行数据的添加。而且全部出列后不能进行队列的重用。 初始值：front = 0;rear = 0; 队列满条件：rear == maxSize 队列空条件：rear == front 添加数据rear后移：rear++; 获取数据，头部后移：front++; package im.bool.a02_queue; import java.util.Scanner; /** * #Author : ivanl001 * #Date : 2020/2/8 11:41 AM * #Desc : 这个把rear默认等于0， front也默认等于0，相当于环形队列初始值再重新做一下，好和环形队列逻辑基本一致 **/ public class a02_queueByArray01 { public static void main(String[] args) { ArrayQueue01 queue = new ArrayQueue01(3); char key; Scanner scanner = new Scanner(System.in); boolean loop = true; while(loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出\"); System.out.println(\"a(add): 添加队列\"); System.out.println(\"g(get): 获取\"); System.out.println(\"h(head): 显示头部数据\"); System.out.println(\"i(info): 显示头部数据\"); key = scanner.next().charAt(0); switch (key) { case 's': queue.showQueue(); break; case 'a': System.out.println(\"输入数据：\"); int value = scanner.nextInt(); queue.addToQueue(value); break; case 'g': try { int res = queue.getDataFromQueue(); System.out.println(\"数据是：\\n\" + res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'h': try { int res = queue.showHeadData(); System.out.printf(\"头部数据是：%d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'i': try { queue.showInfo(); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'e': scanner.close(); loop = false; break; default: break; } } System.out.println(\"程序退出\"); } } class ArrayQueue01 { //队列最大容量 private final int maxSize; //队列第一个位置 private int front; //队列最后一个元素位置 private int rear; //存放数据的地方，模拟队列 private final int[] arr; //这个是构造方法 public ArrayQueue01(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; //这里都定义成0，代表执行队列头部 front = 0; rear = 0; } public void addToQueue(int n) { if (isFull()) { System.out.println(\"队列已满，不能添加数据\"); return; } //先赋值然后再后移 arr[rear] = n; rear++; } //判断队列是否满了 public boolean isFull() { return rear == maxSize; } public boolean isEmpty() { return rear == front; } public int getDataFromQueue() { if (isEmpty()) { System.out.println(\"队列为空，不可取数据\"); throw new RuntimeException(\"队列为空异常\"); } int data = arr[front]; front++; return data; } //显示队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空，直接返回\"); return; } for (int i = front; i 环形队列 数组模拟环形队列,需要用到一些算法 初始值：front = 0;rear = 0; 队列满条件：(rear+1)%maxSize == front， 因为是环形队列， 能循环使用，所以不能直接rear=front，因为默认空的时候也满足这个条件。所以只能空一个数据出来，这样只有数据满的时候才会满足(rear+1)%maxSize == front 队列空条件：rear == front 添加数据rear后移：rear = (rear+1)%maxSize; 获取数据，头部后移：front = (front+1)%maxSize; 环形队列有一个限制：队列大小不能为1，因为算法中在数组中预留了一个位置，如果队列大小是1，那么队列永远是满的 package im.bool.a02_queue; import java.util.Scanner; /** * #Author : ivanl001 * #Date : 2019/11/9 14:46 * #Desc : 数组模拟成环形队列 * 思路分析：之前的数组模拟简单队列：front表示头部，指向队列的队列的前一个位置， rear表示尾部。 * 模拟环形队列需要把front改变一下， front执行队列的第一个元素 * rear也要改变一下，rear指向队列最后一个元素。因为希望空出一个空间作为约定。 * 那么当队列满时候，则：rear+1-front = maxSize **/ public class a03_circleQueueByArray { public static void main(String[] args) { CircleArray queue = new CircleArray(1); char key = ' '; Scanner scanner = new Scanner(System.in);// boolean loop = true; while(loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出\"); System.out.println(\"a(add): 添加队列\"); System.out.println(\"g(get): 获取\"); System.out.println(\"h(head): 显示头部数据\"); System.out.println(\"i(info): 显示头部数据\"); key = scanner.next().charAt(0); switch (key) { case 's': queue.showQueue(); break; case 'a': System.out.println(\"输入数据：\"); int value = scanner.nextInt(); queue.addToQueue(value); break; case 'g': try { int res = queue.getDataFromQueue(); System.out.println(\"数据是：\\n\" + res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'h': try { int res = queue.showHeadData(); System.out.printf(\"头部数据是：%d\\n\", res); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'i': try { queue.showInfo(); } catch (Exception e) { // TODO: handle exception System.out.println(e.getMessage()); } break; case 'e': scanner.close(); loop = false; break; default: break; } } System.out.println(\"程序退出\"); } } class CircleArray { private final int maxSize; //front初始值为0 private int front; //rear初始值为0 private int rear; private final int[] arr; public CircleArray(int arrMaxSize) { /*if (arrMaxSize 1.3, 链表 链表是以节点的方式来存储,是链式存储 每个节点包含 data 域， next 域：指向下一个节点. 如图：发现链表的各个节点不一定是连续存储. 链表分为：==带头节点的链表==和==没有头节点的链表==，根据实际的需求来确定 单向链表 单链表反转 使用新的链表，把老链表下一个节点插入新链表头部， 最后把新链表赋值给老链表 //面试题：单链表的反转 //思路： // 1，链表只要有头节点head，通过head可以找到完整的链表 // 2, 先新建一个临时tempHead，把head的下一个节点node1，剪切放入到临时链表的头节点后面。 // 3, 然后head的下一个节点，也就是原先链表的第二个节点node2，成为了原先链表的第一个节点，重复2，也就是剪切放入到临时链表的头节点的后面，也就是tempHead和node1中间，然后就变成临时节点的倒数第二个节点了 // 4, 重复上面的步骤， 直到原链表head后面的节点全部在临时链表中排序好 // 5, 最后把临时链表中的数据，赋值给head即可 public void reverse() { // 链表为空或者链表只有一个除head之外的节点，则不需要反转 if (head.next == null || head.next.next == null) { System.out.println(\"无数据库或者数据仅有1个，无需反转即使正确的\"); return; } // 定义一些辅助变量指针，帮我们遍历原来的链表 HeroNode current = head.next; HeroNode next; // 这个头是先用来把数据排好序，最后再把排好序的数据部分赋值给head HeroNode tempHead = new HeroNode(0, \"\", \"\"); while (current != null) { // 先暂时保存current节点的下一个节点，要不到时候就找不到进入口了。因为current到时候会给temp，到时候current的next就会变掉了 next = current.next; // 把current夹在新的排序的链表head节点紧着后面，依次下来之后就相当于反转了。 current.next = tempHead.next; tempHead.next = current; //再把原先的链表删除掉已经添加到新的链表中的那个节点 current = next; } //最后把排序的链表重新赋值给原链表即可 head.next = tempHead.next; //到这里原链表就被拷贝到新的链表上排好序，又给赋值回来了 单链表逆序打印(不改变元链表) ==放入栈中== // 面试题：逆序打印单链表的节点 // 先遍历，取出来后放入栈中，然后逐步pop出来即可 public void printDesc() { if (head.next == null) { System.out.println(\"空链表\"); return; } Stack heroNodes = new Stack(); HeroNode temp = head.next; while (temp != null) { heroNodes.push(temp); temp = temp.next; } while (heroNodes.size() > 0) { System.out.println(heroNodes.pop()); } } ==使用迭代== //注意：这里是个静态方法，只需要传入链表的第一个节点即可 public static void printDesc_v1(HeroNode node) { if (node != null) { printDesc_v1(node.next); } if (node != null) { System.out.println(node); } } 链表的真正代码 如下代码中链表包含一个头节点，改节点作为定位节点，不存储任何数据信息 如下代码包含链表的创建， 新增，更改，删除等等 package im.bool.a03_linked_list; import java.util.Stack; /** * #Author : ivanl001 * #Date : 2020/2/8 5:43 PM * #Desc : 一个简单的单向链表的实现 **/ public class a03_01_singleLinkedList { public static void main(String[] args) { //这个是按照添加顺序进行排序 HeroNode heroNode01 = new HeroNode(1, \"宋江\", \"及时雨\"); HeroNode heroNode02 = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); HeroNode heroNode03 = new HeroNode(3, \"吴用\", \"智多星\"); HeroNode heroNode04 = new HeroNode(4, \"林冲\", \"豹子头\"); SingleLinkedList singleLinkedList = new SingleLinkedList(); singleLinkedList.add(heroNode01); singleLinkedList.add(heroNode04); singleLinkedList.add(heroNode02); singleLinkedList.add(heroNode03); singleLinkedList.showLinkedList(); /*singleLinkedList.reverse(); System.out.println(\"逆序\"); singleLinkedList.showLinkedList();*/ System.out.println(\"逆序打印，不会改变原始结构\"); singleLinkedList.printDesc(); //这个是按照英雄编号进行排序，跟添加顺序无关 /*HeroNode heroNode01 = new HeroNode(1, \"宋江\", \"及时雨\"); HeroNode heroNode02 = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); HeroNode heroNode03 = new HeroNode(3, \"吴用\", \"智多星\"); HeroNode heroNode04 = new HeroNode(4, \"林冲\", \"豹子头\"); SingleLinkedList singleLinkedList = new SingleLinkedList(); System.out.println(singleLinkedList.getSize()); singleLinkedList.addByOrder(heroNode01); singleLinkedList.addByOrder(heroNode03); singleLinkedList.addByOrder(heroNode03); singleLinkedList.addByOrder(heroNode02); singleLinkedList.addByOrder(heroNode04); singleLinkedList.showLinkedList();*/ /*System.out.println(singleLinkedList.getSize()); System.out.println(singleLinkedList.getndNode(4)); System.out.println(\"--------------\"); System.out.println(singleLinkedList.getLstndNode(3));*/ /*heroNode01 = new HeroNode(3, \"zhangdanfeng\", \"及时雨\"); singleLinkedList.updateHeroNode(heroNode01); singleLinkedList.showLinkedList(); System.out.println(\"-------------------------\"); singleLinkedList.deleteHeroNodeByNo(3); singleLinkedList.showLinkedList(); System.out.println(\"-------------------------\"); singleLinkedList.deleteHeroNodeByNo(2); singleLinkedList.showLinkedList(); System.out.println(\"-------------------------\"); singleLinkedList.deleteHeroNodeByNo(1); singleLinkedList.deleteHeroNodeByNo(1); singleLinkedList.showLinkedList(); System.out.println(\"-------------------------\"); singleLinkedList.deleteHeroNodeByNo(4); singleLinkedList.showLinkedList(); System.out.println(\"-------------------------\"); singleLinkedList.deleteHeroNodeByNo(5); singleLinkedList.showLinkedList();*/ } // 迭代实现逆序打印 public static void printDesc_v1(HeroNode node) { if (node != null) { printDesc_v1(node.next); } if (node != null) { System.out.println(node); } } } class SingleLinkedList { //先定义一个头节点，头节点什么都不存， 且不能改动 private HeroNode head = new HeroNode(0, \"\", \"\"); //面试题：逆序打印单链表的节点 //先遍历，取出来后放入栈中，然后逐步pop出来即可 public void printDesc() { if (head.next == null) { System.out.println(\"空链表\"); return; } Stack heroNodes = new Stack(); HeroNode temp = head.next; while (temp != null) { heroNodes.push(temp); temp = temp.next; } while (heroNodes.size() > 0) { System.out.println(heroNodes.pop()); } } //面试题：单链表的反转 //思路：1，链表只要有头节点head，通过head可以找到完成的链表 //2, 先新建一个临时tempHead，把head的下一个节点node1，剪切放入到临时链表的头节点后面。 //3, 然后head的下一个节点，也就是原先链表的第二个节点node2，成为了原先链表的第一个节点，重复2，也就是剪切放入到临时链表的头节点的后面，也就是tempHead和node1中间，然后就变成临时节点的倒数第二个节点了 //4, 重复上面的步骤， 直到原链表head后面的节点全部在临时链表中排序好 //5, 最后把临时链表中的数据，赋值给head即可 public void reverse() { if (head.next == null || head.next.next == null) { System.out.println(\"无数据库或者数据仅有1个，无需反转即使正确的\"); return; } //定义一些辅助变量指针，帮我们遍历原来的链表 HeroNode current = head.next; HeroNode next; //这个头是先用来把数据排好序，最后再把排好序的数据部分赋值给head HeroNode tempHead = new HeroNode(0, \"\", \"\"); while (current != null) { next = current.next;//先暂时保存current节点的下一个节点，要不到时候就找不到进入口了。因为current到时候会给temp，到时候current的next就会变掉了 //把current夹在新的排序的链表head节点紧着后面，依次下来之后就相当于反转了。 current.next = tempHead.next; tempHead.next = current; //再把原先的链表删除掉已经添加到新的链表中的那个节点 current = next; } //最后把排序的链表重新赋值给原链表即可 head.next = tempHead.next; //到这里原链表就被拷贝到新的链表上排好序，又给赋值回来了 } //获取倒数第n个节点 public HeroNode getLstndNode(int n) { if (n > getSize()) { System.out.println(\"该链表一共\" + getSize() + \"个元素\"); return null; } int theNo = getSize() - n + 1; return getndNode(theNo); } //获取正数第n个节点 public HeroNode getndNode(int n) { if (n > getSize()) { System.out.println(\"该链表一共\" + getSize() + \"个元素\"); return null; } HeroNode temp = head; for (int i = 0; i heroNode.no) { break; } else if (temp.next.no == heroNode.no){ //说明编号已经存在 isExistFlag = true; break; } else { //需要往后移 temp = temp.next; } } if (isExistFlag) { //说明已经存在 System.out.println(\"已经存在\"); } else { //说明需要放在temp之前 //这两句的顺序不能换 heroNode.next = temp.next; temp.next = heroNode; } } //添加节点到单向列表思路：找到当前链表的最后一个节点，使该节点的next指向新的节点即可 public void add(HeroNode heroNode) { HeroNode temp = head; while (true) { if (temp.next == null) { //说明找到最后一个节点，即head即使最后一个节点 temp.next = heroNode; break; } //如果不是空，则需要把节点往后移动一个 temp = temp.next; } } public void showLinkedList() { if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为head不存储数据，所以直接从head.next开始即可 HeroNode temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); temp = temp.next; } } } class HeroNode { public int no; public String name; public String nickName; public HeroNode next; public HeroNode(int no, String name, String nickName) { this.no = no; this.name = name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + \", nickName='\" + nickName + '\\'' + // \", next=\" + next + '}'; } } 双向链表 单向链表，查找的方向只能是一个方向，而双向链\u000b表可以向前或者向后查找。 单向链表不能自我删除，需要靠辅助节点(如果自我删除，那么前面的节点就无法和后面的节点连接起来了) ，而双向\u000b链表，则可以自我删除，所以前面我们单链表删除\u000b时节点，总是找到temp,temp是待删除节点的前一\u000b个节点(认真体会). package im.bool.a03_linked_list; /** * #Author : ivanl001 * #Date : 2020/2/10 8:22 AM * #Desc : 双向链表 **/ public class a03_02_DoubleLinkedList { //双向链表的测试 public static void main(String[] args) { //这个是按照添加顺序进行排序 /*HeroNode heroNode01 = new HeroNode(1, \"宋江\", \"及时雨\"); HeroNode heroNode02 = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); HeroNode heroNode03 = new HeroNode(3, \"吴用\", \"智多星\"); HeroNode heroNode04 = new HeroNode(4, \"林冲\", \"豹子头\"); DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(heroNode01); doubleLinkedList.add(heroNode04); doubleLinkedList.add(heroNode02); doubleLinkedList.add(heroNode03); doubleLinkedList.showLinkedList(); HeroNode heroNode004 = new HeroNode(4, \"林冲0000\", \"豹子头\"); doubleLinkedList.updateHeroNode(heroNode004); System.out.println(\"update\"); doubleLinkedList.showLinkedList(); doubleLinkedList.deleteHeroNodeByNo(4); System.out.println(\"delete\"); doubleLinkedList.showLinkedList();*/ //这个是按照添加顺序进行排序 HeroNode heroNode01 = new HeroNode(1, \"宋江\", \"及时雨\"); HeroNode heroNode02 = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); HeroNode heroNode03 = new HeroNode(3, \"吴用\", \"智多星\"); HeroNode heroNode04 = new HeroNode(4, \"林冲\", \"豹子头\"); DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.addByOrder(heroNode01); doubleLinkedList.addByOrder(heroNode04); doubleLinkedList.addByOrder(heroNode02); doubleLinkedList.addByOrder(heroNode03); doubleLinkedList.showLinkedList(); } } class DoubleLinkedList { //先定义一个头节点，头节点什么都不存， 且不能改动 private HeroNode head = new HeroNode(0, \"\", \"\"); public void deleteHeroNodeByNo(int no) { if (head.next == null) { System.out.println(\"没有数据节点，也即是没有数据\"); return; } //这里直接找到需要删除的节点即可，不需要删除删除节点的前一个节点 HeroNode temp = head.next; while (true) { if (temp == null) { System.out.println(\"无对应no的heroNode\"); return; } else if (temp.no == no) { //找到 //把删除节点的前一个节点和删除节点的后一个节点连接起来，就相当于删除了当前节点，因为当前节点无引用，就会自动被清理。 temp.pre.next = temp.next; //删除最后一个节点的时候，next可能为空 if (temp.next != null) { temp.next.pre = temp.pre; } break; } temp = temp.next; } } public void updateHeroNode(HeroNode heroNode) { HeroNode temp = head; while (true) { if (temp.next == null) { System.out.println(\"无对应no的heroNode\"); return; } else if (temp.no == heroNode.no) { //找到 temp.pre.next = heroNode; heroNode.pre = temp.pre; heroNode.next = temp.next; temp.next.pre = heroNode; // temp.name = heroNode.name; // temp.nickName = heroNode.nickName; break; } temp = temp.next; } } public void addByOrder(HeroNode heroNode) { HeroNode temp = head; //这个是表明是有已经拥有相同编号的HeroNode boolean isExistFlag = false; while (true) { if (temp.next == null) { break; } if (temp.next.no > heroNode.no) { break; } else if (temp.next.no == heroNode.no){ //说明编号已经存在 isExistFlag = true; break; } else { //需要往后移 temp = temp.next; } } if (isExistFlag) { //说明已经存在 System.out.println(\"已经存在\"); } else { //说明需要放在temp之前 //这两句的顺序不能换 /*heroNode.next = temp.next; temp.next = heroNode; temp.next.pre = heroNode; heroNode.pre = temp;*/ if (temp.next == null) { //说明需要放在最后面即可 temp.next = heroNode; heroNode.pre = temp; } else { //先把heronode指向别人。 heroNode.pre = temp; heroNode.next = temp.next; //再断开别人之间的连接，指向heronode temp.next.pre = heroNode; temp.next = heroNode; } } } //添加节点到单向列表思路：找到当前链表的最后一个节点，使该节点的next指向新的节点即可 public void add(HeroNode heroNode) { HeroNode temp = head; while (true) { if (temp.next == null) { //说明找到最后一个节点，即head即使最后一个节点 temp.next = heroNode; heroNode.pre = temp; break; } //如果不是空，则需要把节点往后移动一个 temp = temp.next; } } public void showLinkedList() { if (head.next == null) { System.out.println(\"链表为空\"); return; } //因为head不存储数据，所以直接从head.next开始即可 HeroNode temp = head.next; while (true) { if (temp == null) { break; } System.out.println(temp); temp = temp.next; } } public HeroNode getHeadNode() { return head; } } 单向环形链表：约瑟夫问题 因为是单向，所以在出圈的时候，需要一个point指向出圈元素的前一个位置，不然没法把出圈元素踢出圈子 package im.bool.a03_linked_list; import java.util.ArrayList; import java.util.List; /** * #Author : ivanl001 * #Date : 2020/2/10 3:36 PM * #Desc : 约瑟夫问题解决-即单向环形列表 **/ public class a03_03_Josepfu { public static void main(String[] args) { SingleCircleLinkedList circleLinkedList = new SingleCircleLinkedList(); circleLinkedList.addBoy(5); circleLinkedList.showBoy(); System.out.println(\"ivanl001\"); circleLinkedList.josepfuOrder(2, 3, 5); } } class SingleCircleLinkedList { //这个是个指针节点 private Boy first = new Boy(-1); /* *startNo 开始的数字 *countNum 数几下 *nums 最开始一共有几个小孩在圈上 */ public void josepfuOrder(int startNo, int countNum, int nums) { //参数啥的我这里就不校验了 List theOrder = new ArrayList(); Boy boy = first; //还需要一个辅助指针，需要指向first前面一个指针，找到这个指针，需要正向移动一圈 Boy pointer = first; while (true) { System.out.println(\"0000000000\"); if (pointer.getNext() == first) { break; } //如果pointer不是first的前一个，那么就接着往后移动 pointer = pointer.getNext(); } //因为是从startNo开始报数的，所以需要先移动startNo-1个位置 for (int i = 0; i 1.4, 哈希表 HashTable是由数组和链表(或者红黑树)共同组成的一种数据结构. 通过hash来确定是数据所归属的链表。 最下层是Student学生模型类 中间是链表模型，用户管理每个元素的添加和查找 上层是HashTable类，这个类包含一个链表数组，用于管理hash值 package im.bool.a08_hash_table; import java.util.Scanner; /** * @author : 不二 * @date : 2021/5/7-下午5:35 * @desc : hashtable重新再写一遍 **/ public class a08_01_HashTableDemo01 { public static void main(String[] args) { StudentHashTable table = new StudentHashTable(10); String key = \"\"; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示所有雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); // Employee employee = new Employee(id, name); Student student = new Student(id, name); table.addStudent(student); break; case \"list\": table.listHashTable(); break; case \"find\": System.out.println(\"请输入id\"); int id01 = scanner.nextInt(); table.findStudentById(id01); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } } } class StudentHashTable { private int tableSize; private StudentLinkedList[] hashTable; public int hash(int id) { return id % tableSize; } public void addStudent(Student student) { hashTable[hash(student.getId())].addStudent(student); } public void listHashTable() { for (int i = 0; i \"); current = current.next; } System.out.println(current.getName()); } } public void findStudentById(int id) { if (head == null) { System.out.println(\"链表中无此id\"); } else { Student student = head; Student target = null; while (student != null) { if (student.getId() == id) { target = student; break; } student = student.next; } if (target != null) { System.out.println(\"根据id找到数据:id:\" + target.getId() + \",name:\" + target.getName()); } else { System.out.println(\"链表中无此id\"); } } } } // 带有所有字段的getter和setter方法，并有空参构造器和满参构造器的java类--java bean class Student { private int id; private String name; public Student next; public Student() { } public Student(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 1.5, 栈 栈的基本概念 栈的英文为(stack) 栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 栈的应用 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历。 图形的深度优先(depth一first)搜索法。 栈模拟 数组模拟 package im.bool.a04_stack; import java.util.Arrays; import java.util.Scanner; /** * #Author : ivanl001 * #Date : 2020/2/11 10:09 AM * #Desc : 用数组模拟栈 **/ public class a04_01_StackByArray { public static void main(String[] args) { ArrayStack stack = new ArrayStack(4); String key = \"\"; boolean loop = true; Scanner scanner = new Scanner(System.in); while (loop) { System.out.println(\"show\"); System.out.println(\"exist\"); System.out.println(\"push\"); System.out.println(\"pop\"); System.out.println(\"请输入\"); key = scanner.next(); if (\"show\".equals(key)) { stack.showStack(); } else if (\"exist\".equals(key)) { scanner.close(); loop = false; } else if (\"push\".equals(key)) { System.out.println(\"请输入一个数字：\"); int value = scanner.nextInt(); stack.push(value); System.out.println(\"入栈完成\"); } else if (\"pop\".equals(key)) { int value01 = stack.pop(); System.out.println(\"出栈的数字是：\" + value01); } else { System.out.println(\"输入错误，请重新输入:\"); break; } } } } class ArrayStack { private int maxSize; private int[] stack; //入栈的时候position加1，出栈的时候position减1，这样子就可以模拟出先入的后出 private int position = -1; public ArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } public boolean isFull() { return position == maxSize - 1; } public boolean isEmpty() { return position == -1; } public void push(int value) { if (isFull()) { System.out.println(\"full-----\"); return; } position++; stack[position] = value; } public int pop() { if (isEmpty()) { System.out.println(\"empty----\"); throw new RuntimeException(\"empty--\"); } int value = stack[position]; position--; return value; } public void showStack() { if (isEmpty()) { System.out.println(\"empty\"); return; } for (int i = position; i >= 0; i--) { System.out.printf(\"stack[%d]=%d \\n\", i, stack[i]); } } } 栈实现计算器 package im.bool.a04_stack; import java.sql.Struct; /** * #Author : ivanl001 * #Date : 2020/2/16 8:57 PM * #Desc : 通过栈摸模拟计算器 **/ public class a04_02_Calculator { public static void main(String[] args) { String expStr = \"111+2*6-2\"; //需要根据上面的字符串计算结果，需要创建两个栈：1，数栈 2，符号栈 CalcArrayStack numStack = new CalcArrayStack(10); CalcArrayStack operStack = new CalcArrayStack(10); int index = 0; int num1 = 0; int num2 = 0; int oper = 0; int res = 0; char ch = ' '; String keepNum = \"\";//用于多位数字的通过字符拼接起来，才能正确的计算多位数 while (true) { ch = expStr.substring(index, index + 1).charAt(0); if (operStack.isOper(ch)) { if (!operStack.isEmpty()) { //说明符号栈中已经存在符号，需要根据两个符号的优先级进行处理 if (operStack.getPriority(ch) = expStr.length()) { //说明已经是最后一个数字了 break; } } //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出对应的数字和符号，进行运算即可 while (true) { if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); int temp = numStack.cal(num1, num2, oper); numStack.push(temp); } System.out.println(\"结果是：\" + numStack.pop()); } } class CalcArrayStack { private int maxSize; private int[] stack; //入栈的时候position加1，出栈的时候position减1，这样子就可以模拟出先入的后出 private int position = -1; public CalcArrayStack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } public int peekTop() { return stack[position]; } //计算方法，num1是先被出栈的数字，num2是后出栈的顺序，计算减法和除法的时候需要留意顺序 public int cal(int num1, int num2, int oper) { int result = 0; switch (oper) { case '+': result = num1+num2; break; case '-': result = num2-num1; break; case '*': result = num1*num2; break; case '/': result = num2/num1; break; } return result; } //判断字符是不是运算符 public boolean isOper(int val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //优先级使用数字表示，数据越大，优先级越高.char类型可以和int类型相互转换的哈 public int getPriority(int oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' | oper == '-') { return 0; } else { return -1; } } public boolean isFull() { return position == maxSize - 1; } public boolean isEmpty() { return position == -1; } public void push(int value) { if (isFull()) { System.out.println(\"full-----\"); return; } position++; stack[position] = value; } public int pop() { if (isEmpty()) { System.out.println(\"empty----\"); throw new RuntimeException(\"empty--\"); } int value = stack[position]; position--; return value; } public void showStack() { if (isEmpty()) { System.out.println(\"empty\"); return; } for (int i = position; i >= 0; i--) { System.out.printf(\"stack[%d]=%d \\n\", i, stack[i]); } } } ==-----------如下计算器以及波兰表达式内容后续有时间再看-------------== 1.6, 计算器实现的波兰表达式和逆波兰表达式 前缀表达式(波兰表达式) 波兰表达式又称前缀表达式，就是运算符位于操作数之前 举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下: 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 中缀表达式(正常的计算表达式) 举例说明： (3+4)×5-6 就是中缀表达式 后缀表达式(逆波兰表达式) 逆波兰表达式又称后缀表达式，与前缀表达式相似，只是运算符位于操作数之后 举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 中缀表达式 逆波兰表达式(后缀表达式) a+b a b + a+(b-c) a b c - + a+(b-c)*d a b c – d * + a+d*(b-c) a d b c - * + a=1+3 a 1 3 + = 后缀表达式的计算机求值 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下: 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 package im.bool.a04_stack; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Stack; /** * #Author : ivanl001 * #Date : 2020/2/16 11:10 PM * #Desc : 逆波兰表达式计算器:给定一个逆波兰表达式，计算出结果 *。 如何把常用的正常的计算式子转换成逆波兰表达式可以看后面的内容 **/ public class a04_03_ReversePolandNotation { public static void main(String[] args) { //先定义逆波兰表达式 //(3+4)*5-6 //String expStr = \"3 4 + 5 × 6 - \"; //4*5-8+60+8/2 4 5 * 8 - 60 + 8 2 / + String expStr = \"4 5 × 8 - 60 + 8 2 / +\"; int result = calc(getListString(expStr)); System.out.println(\"结果是: \" + result); } public static List getListString(String reversePolandNotionStr) { //把逆波兰表达式根据空格切开，然后放入数组方便后续进行计算 List elements = new ArrayList(); String[] splitExp = reversePolandNotionStr.split(\" \"); Collections.addAll(elements, splitExp); return elements; } /* 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下: 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 */ public static int calc(List elemets) { //创建栈 Stack stack = new Stack(); for (String item : elemets) { //使用正则表达式取出数字 if (item.matches(\"\\\\d+\")) { stack.push(item); } else { //如果不是数字，那么就pop出两个数字，进行运算，然后重新入栈 int num1 = Integer.parseInt(stack.pop()); int num2 = Integer.parseInt(stack.pop()); int result = 0; if (item.equals(\"+\")) { result = num1 + num2; } else if (item.equals(\"-\")) { result = num2 - num1; } else if (item.equals(\"×\")) { result = num1 * num2; } else if (item.equals(\"/\")) { result = num2/num1; } else { throw new RuntimeException(\"暂不支持的运算符号\"); } stack.push(result + \"\"); } } //最终留在栈中的即是结果 return Integer.parseInt(stack.pop()); } } 中缀表达式转化为后缀表达式(逆波兰表达式) 这里感觉用处不大，知道了大致的内容，具体的代码就不写了。 ==-----------如上计算器以及波兰表达式内容后续有时间再看-------------== 1.7, 案例实战 下面实战中会使用到迭代(算法)，下面先简单学习一下 迭代的基本应用 package im.bool.a05_recursive_stack; /** * #Author : ivanl001 * #Date : 2020/2/23 9:06 AM * #Desc : 迭代算法的一些基本应用 **/ public class a05_01_Recursive { public static void main(String[] args) { //打印递归 //这里打印10 9 8 7 6 5 4 3 2 1从大到小 // printRecursively(10); //这里打印1 2 3 4 5 6 7 8 9 10从小到大 // printRecursively01(10); //这里只会打印0 // printRecursively02(10); //阶乘问题 int factorial = factorial(10); System.out.println(factorial); } public static int factorial(int n) { if (n == 1) { return 1; } else { return factorial(n-1)*n; } } public static void printRecursively02(int n) { if (n >= 1) { printRecursively02(n-1); } else { System.out.println(n); } } public static void printRecursively01(int n) { if (n >= 1) { printRecursively01(n-1); } System.out.println(n); } public static void printRecursively(int n) { if (n >= 1) { System.out.println(n); printRecursively(n-1); } } } 迷宫问题 package im.bool.a05_recursive_stack; /** * #Author : ivanl001 * #Date : 2020/2/21 8:26 AM * #Desc : 通过递归实现迷宫回溯问题 **/ public class a05_02_Labyrinth { public static void main(String[] args) { //1, 模拟迷宫 int[][] labyrinth = new int[8][7]; //2, set column0 and column6 as wall for (int i = 0; i 八皇后问题 当前行如果验证通过， 走下一行 如果验证不通过， 先把当前行往后移，验证通过，走下一行，验证不通过， 就接着往后移。如果依然不通过， 依然往后移。直到超过8 超过8的话， 那么就接着走上一行。结果是：要么通过， 然后走下一行，从0开始， 接着重新走。要么不通过，再回溯到上一行。 package im.bool.a05_recursive_stack; /** * @author : 不二 * @date : 2021/4/25-下午7:31 * @desc : 八皇后问题算法 * 卧槽， 这个太难了，看了视频， 没看明白， 画了图也没明白， 然后把代码嵌套写出来， 又画图，看了3个多小时才明白 * 当前行如果验证通过， 走下一行 * 如果验证不通过， 先把当前行往后移，验证通过，走下一行，验证不通过， 就接着往后移。如果依然不通过， 依然往后移。直到超过8 * 超过8的话， 那么就回走上一行。结果是：要么通过， 然后走下一行，从0开始， 接着重新走。要么不通过，再回溯到上一行。 * **/ public class a05_03_Queue8 { public static void main(String[] args) { // 主方法 a05_03_Queue8 queue8 = new a05_03_Queue8(); queue8.check(0); } // 设置皇后个数 int max = 8; // 定义一个数组, 分别保存第i行的位置 如：arr = {0, 4, 7, 5, 2, 6, 1, 3} // 索引表示第几行， 值表示该行上皇后放置在第几列0代表第0行，皇后放置在第0个位置 int[] array = new int[max]; // 开始放置内容 // n是第几行 private void check(int n) { // 说明n == 8 了， 八个皇后已经全部放好 if (n == max) { // 这里调用的是我们自己写的打印结果的方法 print(); return; } for (int i = 0; i var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/02-hanshunping/01-数据结构-01-线形数据结构.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/02-hanshunping/01-数据结构-02-非线形数据结构.html":{"url":"01-algthrim/02-hanshunping/01-数据结构-02-非线形数据结构.html","title":"01-数据结构-02-非线形数据结构","keywords":"","body":"1.1. 数据结构1.1.1. 2, 非线性结构[toc] 1.1. 数据结构1.1.1. 2, 非线性结构 1.1. 数据结构 数据结构是算法的基础 数据结构分为线性结构和非线性结构 1.1.1. 2, 非线性结构 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构 数组每次插入都需要复制当前数据到一个新的数据才能有类似扩容的功能。List其实是一种优化的数组，会尽量批量扩容，不会每次插入扩容，底层使用的还是数组。这种因素导致数组在插入的时候速度慢。 然后链表的话插入的时候速度就很快了，但是查找的时候，如果链表数据很多，就需要从头查找到尾部，其实相对而言查找速度就比较慢。 这就是学习树结构的原因。 2.1, 二维数组 ==一维数组为线型结构，但是二维数组则为非线形结构== 稀疏数组(sparseArray) 稀疏数组其实是一个二维数组，这里放在线性结构的数组里面并不合适。所以放入非线性结构的二维数组中记录 稀疏数组：数组中有多少个非0数字， 其转化成稀疏数组后， 对应的行数为数字个数+1，其列数固定为3列； 其中第0行：记录数组的总总行数列数以及对应的非0数字个数 第i行分别记录第i个不为的数字的行数，列数以及具体值 package im.bool; /** * #Author : ivanl001 * #Date : 2019/11/2 14:12 * #Desc : 稀疏数组-棋盘的应用 **/ public class a01_sparseArray { public static void main(String[] args) { //棋盘 11*11 //0表示没有棋子，1表示黑子， 2表示蓝子 int[][] chessArr = new int[11][11]; chessArr[1][2] = 1; chessArr[2][3] = 2; chessArr[2][4] = 2; chessArr[3][4] = 2; System.out.println(\"原始棋盘二维数组是：------------------------------------\"); printArr(chessArr); /*for (int[] row : chessArr) { for (int num : row) { System.out.printf(num + \"\\t\"); } System.out.println(\"\\n\"); }*/ System.out.println(\"开始转换成稀疏数组：-------------------------------------\"); //1，先遍历二维数组，得到非0数据个数 int sum = 0; for (int[] ints : chessArr) { for (int anInt : ints) { if (anInt != 0) { sum++; } } } System.out.println(\"遍历之后获取到非零数据个数：\" + sum); //2, 创建稀疏数组 int[][] sparseArr = new int[1 + sum][3]; //3, 给稀疏数组赋值 //-------第一行是整体描述--------- //说明原先数组有11行 sparseArr[0][0] = 11; //说明原先数组有11列 sparseArr[0][1] = 11; //说明原先数组有sum个不为零到数字 sparseArr[0][2] = sum; //-------其余行是非零描述-------- int count = 0; for (int i = 0; i 2.2, 多维数组 # 跳过不表 2.3, 树结构 # 为什么需要树结构? # 1, 数组查询速度快，但是插入速度慢，因为插入的时候实际是进行数组的复制 # 2, 链表插入速度快，但是查询的时候需要重头开始遍历，速度又会有一定限制 # 如果使用树结构，可以实现查询速度较快，插入速度也较快 满二叉树：所有的叶子结点都是在最后一级 遍历的时候看主节点，先遍历主节点就是前序遍历，中间遍历主节点，是中序遍历，最后遍历主节点，是后序遍历 ==前序遍历==: 先遍历主节点，然后遍历左节点，最后遍历右节点 ==中序遍历==: 先遍历左节点， 然后遍历主节点，最后遍历右节点 ==后序遍历==: 先遍历左节点，然后遍历右节点，最后遍历主节点 1, 二叉树的遍历/查找/删除 package im.bool.a09_tree; /** * @author : 不二 * @date : 2021/5/8-下午8:25 * @desc : 二叉树代码重写 * 包括二叉树前中后三种遍历方式 * 以及二叉树的前中后三种查找方式 * 以及二叉树的元素删除 **/ public class a09_01_BinaryTreeDemo_v1 { public static void main(String[] args) { // 首先构造一个数类并添加节点元素 StudentBinaryTree binaryTree = new StudentBinaryTree(); StudentNode heroNode00 = new StudentNode(0, \"1\"); StudentNode heroNode01 = new StudentNode(1, \"1\"); StudentNode heroNode02 = new StudentNode(2, \"2\"); StudentNode heroNode03 = new StudentNode(3, \"3\"); StudentNode heroNode04 = new StudentNode(4, \"4\"); StudentNode heroNode05 = new StudentNode(5, \"5\"); StudentNode heroNode06 = new StudentNode(6, \"6\"); StudentNode heroNode07 = new StudentNode(7, \"7\"); StudentNode heroNode08 = new StudentNode(8, \"8\"); StudentNode heroNode09 = new StudentNode(9, \"9\"); StudentNode heroNode10 = new StudentNode(10, \"10\"); StudentNode heroNode11 = new StudentNode(11, \"11\"); StudentNode heroNode12 = new StudentNode(12, \"12\"); StudentNode heroNode13 = new StudentNode(13, \"13\"); StudentNode heroNode14 = new StudentNode(14, \"14\"); /* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 */ // 设置第一行 binaryTree.setRootStudent(heroNode00); heroNode00.setLeft(heroNode01); heroNode00.setRight(heroNode02); heroNode01.setLeft(heroNode03); heroNode01.setRight(heroNode04); heroNode02.setLeft(heroNode05); heroNode02.setRight(heroNode06); heroNode03.setLeft(heroNode07); heroNode03.setRight(heroNode08); heroNode04.setLeft(heroNode09); heroNode04.setRight(heroNode10); heroNode05.setLeft(heroNode11); heroNode05.setRight(heroNode12); heroNode06.setLeft(heroNode13); heroNode06.setRight(heroNode14); System.out.println(\"前序遍历：\"); binaryTree.preOrder();// 1 2 3 5 4 System.out.println(\"中序遍历：\"); binaryTree.infixOrder();// 2 1 5 3 4 System.out.println(\"后序遍历：\"); binaryTree.suffixOrder();// 2 5 4 3 1 /*System.out.println(\"前序查找：\"); StudentNode studentNode = binaryTree.preOrderSearch(5); System.out.println(studentNode); System.out.println(\"中序查找：\"); StudentNode studentNode1 = binaryTree.infixOrderSearch(5); System.out.println(studentNode1); System.out.println(\"后序查找：\"); StudentNode studentNode2 = binaryTree.suffixOrderSearch(5); System.out.println(studentNode2); // 此处规定：如果删除的是叶子节点，直接删除即可 // 如果删除的是非叶子节点，把该非叶子节点下所有的节点都一并删除掉 System.out.println(\"删除节点：\"); binaryTree.deleteNode(5); System.out.println(\"Ivanl001\");*/ } } class StudentBinaryTree { StudentNode rootStudent; public StudentNode getRootStudent() { return rootStudent; } public void setRootStudent(StudentNode rootStudent) { this.rootStudent = rootStudent; } // 前序查找 public StudentNode preOrderSearch(int id) { return this.rootStudent.preOrderSearch(id); } // 中序查找 public StudentNode infixOrderSearch(int id) { return this.rootStudent.infixSearch(id); } // 后序查找 public StudentNode suffixOrderSearch(int id) { return this.rootStudent.suffixOrderSearch(id); } // 前序遍历(先遍历主节点，然后遍历左节点，最后遍历右节点) public void preOrder() { if (rootStudent == null) { System.out.println(\"该树结构无任何元素\"); } else { this.rootStudent.preOrder(); } } // 中序遍历(先遍历左节点， 然后遍历主节点，最后遍历右节点) public void infixOrder() { if (rootStudent == null) { System.out.println(\"该树结构无任何元素\"); } else { this.rootStudent.infixOrder(); } } // 后序遍历(先遍历左节点，然后遍历右节点，最后遍历主节点) public void suffixOrder() { if (rootStudent == null) { System.out.println(\"该树结构无任何元素\"); } else { this.rootStudent.suffixOrder(); } } public void deleteNode(int i) { if (this.rootStudent.getId() == i) { System.out.println(\"删除的是最顶层根节点，无法删除!\"); } else { this.rootStudent.deleteNode(i); } } } // 这里是个学生类的二叉树子节点 class StudentNode { private int id; private String name; private StudentNode left; private StudentNode right; public StudentNode(int id, String name) { this.id = id; this.name = name; } //删除 public void deleteNode_v1(int no) { //这里和遍历或者查找不一样哈， 因为如果是遍历，是不会返回的 //这里就只能默认只有一个 if (this.left != null && this.left.id == no) { this.left = null; return; } if (this.right != null && this.right.id == no) { this.right = null; return; } if (this.left != null) { this.left.deleteNode(no); } if (this.right != null) { this.right.deleteNode(no); } } public void deleteNode(int id) { if (this.left != null) { if (this.getLeft().getId() == id) { this.setLeft(null); return; } this.left.deleteNode(id); } if (this.right != null) { if (this.getRight().getId() == id) { this.setRight(null); return; } this.right.deleteNode(id); } /*if (this.getLeft().getId() == id) { this.setLeft(null); return; } if (this.getRight().getId() == id) { this.setRight(null); return; }*/ } public StudentNode preOrderSearch(int id) { // 1, 先找根节点 System.out.println(\"开始找到的id为：\" + this.id); if (this.id == id) { return this; } // 2, 然后找左节点 StudentNode studentNode = null; if (this.getLeft() != null) { studentNode = this.getLeft().preOrderSearch(id); } // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了 if (studentNode != null) { return studentNode; } // 3, 最后找右节点 // 如果studentNode 为null，说明还未找到 if (this.getRight() != null) { studentNode = this.getRight().preOrderSearch(id); } // 这里为null说明为找到 return studentNode; } public StudentNode infixSearch(int id) { // 1，先找左节点 StudentNode studentNode = null; if (this.getLeft() != null) { studentNode = this.getLeft().infixSearch(id); } // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了 // 左节点找到直接返回左节点 if (studentNode != null) { return studentNode; } // 2，然后找根节点 // 左节点没找到对比根节点 System.out.println(\"开始找到的id为：\" + this.id); if (this.id == id) { return this; } // 3，最后找右节点 // 如果根节点也没找到，找右节点 // 如果studentNode 为null，说明还未找到 if (this.getRight() != null) { studentNode = this.getRight().infixSearch(id); } // 这里为null说明为找到 return studentNode; } public StudentNode suffixOrderSearch(int id) { // 1，先找左节点 // 左节点找到直接返回左节点 StudentNode studentNode = null; if (this.getLeft() != null) { studentNode = this.getLeft().suffixOrderSearch(id); } // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了 if (studentNode != null) { return studentNode; } // 2，然后找右节点 // 如果左节点没找到，找右节点 // 如果studentNode 为null，说明还未找到 if (this.getRight() != null) { studentNode = this.getRight().suffixOrderSearch(id); } // 如果右侧ok了直接返回就行了 if (studentNode != null) { return studentNode; } // 3，最后找根节点 // 如果左右都没找到， 再对比根节点 System.out.println(\"开始找到的id为：\" + this.id); if (this.id == id) { return this; } // 这里为null说明为找到 return studentNode; } public void preOrder(){ // 先打印出当前 System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } public void suffixOrder() { if (this.left != null) { this.left.suffixOrder(); } if (this.right != null) { this.right.suffixOrder(); } System.out.println(this); } @Override public String toString() { return \"StudentNode{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } public StudentNode getLeft() { return left; } public void setLeft(StudentNode left) { this.left = left; } public StudentNode getRight() { return right; } public void setRight(StudentNode right) { this.right = right; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 2, 顺序存储二叉树 就是通过数组存储二叉树 package im.bool.a09_tree; /** * @author : 不二 * @date : 2021/5/9-下午1:47 * @desc : 数组存储二叉树并实现从数组中按照二叉树的前序中序后序方式读取数据代码重新 **/ public class a09_02_BinaryTreeToArrDemo_v1 { public static void main(String[] args) { //int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}; int[] arr = {1, 3, 6, 8, 10, 14}; ArrBinaryTreeV1 arrBinaryTree = new ArrBinaryTreeV1(arr); System.out.println(\"数组左序遍历：\"); arrBinaryTree.preOrder(); System.out.println(\"数组中序遍历：\"); arrBinaryTree.infixOrder(); System.out.println(\"数组后序遍历：\"); arrBinaryTree.suffixOrder(); } } class ArrBinaryTreeV1 { private final int[] arr; public ArrBinaryTreeV1(int[] arr) { this.arr = arr; } public void preOrder() { preOrder01(0); } // 前序遍历 public void preOrder01(int n) { if (arr != null && arr.length == 0) { System.out.println(\"当前数组为空\"); } System.out.println(arr[n]); int left = 2 * n + 1; int right = 2 * n + 2; if (left 3, 线索化二叉树 n个节点的二叉树链表中含有：==n+1(计算公式:2n-(n-1), 其中2n为n个节点的所有指针数，n-1为n个节点彼此连接的指针数。所有指针减去连接的指针，剩下的就是空指针)==个空指针域。 利用二叉链表中的空指针域，存放指向节点在==某种遍历次序==下的前驱和后继节点的指针，这种附加的指针叫做线索 加上这种线索的二叉树链表又被称为线索链表，相应的二叉树被称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树又分为：前序线索二叉树，中序线索二叉树，后续线索二叉树。 一个节点的前一个节点，称为前驱节点 一个节点的后一个节点，称为后继节点 线索化以及线索化后的二叉树的遍历 其中二叉树的遍历超级巧妙。需要仔细品味 画图更容易理解一些 package im.bool.a09_tree; /** * @author : 不二 * @date : 2021/5/8-下午8:25 * @desc : 线索化二叉树代码重写(之前教程看过，不过前面那份代码没写完， 就删除了，这里重新写一份) * 我们这里通过中序遍历进行线索化二叉树，也就是先线索化左子树，然后线索化当前节点，最后线索化右子树 **/ public class a09_03_ThreadBinaryTreeDemo { public static void main(String[] args) { // 这个是简单的二叉树模型 /*ThreadStudentBinaryTree binaryTree = new ThreadStudentBinaryTree(); ThreadStudentNode heroNode01 = new ThreadStudentNode(1, \"1\"); ThreadStudentNode heroNode03 = new ThreadStudentNode(3, \"3\"); ThreadStudentNode heroNode06 = new ThreadStudentNode(6, \"6\"); ThreadStudentNode heroNode08 = new ThreadStudentNode(8, \"8\"); ThreadStudentNode heroNode10= new ThreadStudentNode(10, \"10\"); ThreadStudentNode heroNode14 = new ThreadStudentNode(14, \"14\"); heroNode01.setLeft(heroNode03); heroNode01.setRight(heroNode06); heroNode03.setLeft(heroNode08); heroNode03.setRight(heroNode10); heroNode06.setLeft(heroNode14); binaryTree.setRootStudent(heroNode01);*/ // 用复杂一点的二叉树看一下效果 // 首先构造一个数类并添加节点元素 ThreadStudentBinaryTree binaryTree = new ThreadStudentBinaryTree(); ThreadStudentNode heroNode00 = new ThreadStudentNode(0, \"1\"); ThreadStudentNode heroNode01 = new ThreadStudentNode(1, \"1\"); ThreadStudentNode heroNode02 = new ThreadStudentNode(2, \"2\"); ThreadStudentNode heroNode03 = new ThreadStudentNode(3, \"3\"); ThreadStudentNode heroNode04 = new ThreadStudentNode(4, \"4\"); ThreadStudentNode heroNode05 = new ThreadStudentNode(5, \"5\"); ThreadStudentNode heroNode06 = new ThreadStudentNode(6, \"6\"); ThreadStudentNode heroNode07 = new ThreadStudentNode(7, \"7\"); ThreadStudentNode heroNode08 = new ThreadStudentNode(8, \"8\"); ThreadStudentNode heroNode09 = new ThreadStudentNode(9, \"9\"); ThreadStudentNode heroNode10 = new ThreadStudentNode(10, \"10\"); ThreadStudentNode heroNode11 = new ThreadStudentNode(11, \"11\"); ThreadStudentNode heroNode12 = new ThreadStudentNode(12, \"12\"); ThreadStudentNode heroNode13 = new ThreadStudentNode(13, \"13\"); ThreadStudentNode heroNode14 = new ThreadStudentNode(14, \"14\"); /* 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 */ // 设置第一行 binaryTree.setRootStudent(heroNode00); heroNode00.setLeft(heroNode01); heroNode00.setRight(heroNode02); heroNode01.setLeft(heroNode03); heroNode01.setRight(heroNode04); heroNode02.setLeft(heroNode05); heroNode02.setRight(heroNode06); heroNode03.setLeft(heroNode07); heroNode03.setRight(heroNode08); heroNode04.setLeft(heroNode09); heroNode04.setRight(heroNode10); heroNode05.setLeft(heroNode11); heroNode05.setRight(heroNode12); heroNode06.setLeft(heroNode13); heroNode06.setRight(heroNode14); // 中序先打印一把 System.out.println(\"中序打印--\"); binaryTree.infixOrder(); // 这里调用重载的方法 binaryTree.threadNodes(); /*ThreadStudentNode studentNode = heroNode10; System.out.println(\"10号节点的左节点:\" + studentNode.getLeft()); System.out.println(\"10号节点的右节点:\" + studentNode.getRight());*/ // 使用线索化遍历 System.out.println(\"使用线索化方式进行遍历--\"); binaryTree.threadedList(); } } class ThreadStudentBinaryTree { ThreadStudentNode rootStudent; // 为了实现线索化，需要锁定前节点 ThreadStudentNode preStudent; public ThreadStudentNode getRootStudent() { return rootStudent; } public void setRootStudent(ThreadStudentNode rootStudent) { this.rootStudent = rootStudent; } // 这里直接方法重载即可 public void threadNodes() { threadNodes(rootStudent); } public void threadedList() { ThreadStudentNode node = rootStudent; while (node != null) { while (node.getLeftType() == 0) { node = node.getLeft(); } // 这里暂时不是特别明白。 System.out.println(node); while (node.getRightType() == 1) { node = node.getRight(); System.out.println(node); } System.out.println(\"------------又一轮---------\"); node = node.getRight(); } } // 二叉树线索化的方法 // 这里再构造方法里面直接线索化即可 public void threadNodes(ThreadStudentNode studentNode) { // System.out.println(studentNode); if (studentNode == null) { // System.out.println(\"节点为null，返回\"); // 当前节点都为null了，那肯定没有左右节点了， 直接返回即可了 return; } // 1, 先线索化左子树(调用当前方法即可) threadNodes(studentNode.getLeft()); // 2, 然后线索化当前节点(真正线索化的内容) if (studentNode.getLeft() == null) { studentNode.setLeft(preStudent); studentNode.setLeftType(1); } // 这里还需要添加个判断：preStudent != null // 注意：这里要判断的是前一个的right是null，别判断成当前节点了，吃亏了 if (preStudent != null && preStudent.getRight() == null) { // 这个相当于是这次处理上个节点的right引用。下次再设置本个节点的right引用。 // 比较巧妙 preStudent.setRight(studentNode); preStudent.setRightType(1); } preStudent = studentNode; // 3, 最后线索化右子树(调用当前方法即可) threadNodes(studentNode.getRight()); } // 前序查找 public ThreadStudentNode preOrderSearch(int id) { return this.rootStudent.preOrderSearch(id); } // 中序查找 public ThreadStudentNode infixOrderSearch(int id) { return this.rootStudent.infixSearch(id); } // 后序查找 public ThreadStudentNode suffixOrderSearch(int id) { return this.rootStudent.suffixOrderSearch(id); } // 前序遍历(先遍历主节点，然后遍历左节点，最后遍历右节点) public void preOrder() { if (rootStudent == null) { System.out.println(\"该树结构无任何元素\"); } else { this.rootStudent.preOrder(); } } // 中序遍历(先遍历左节点， 然后遍历主节点，最后遍历右节点) public void infixOrder() { if (rootStudent == null) { System.out.println(\"该树结构无任何元素\"); } else { this.rootStudent.infixOrder(); } } // 后序遍历(先遍历左节点，然后遍历右节点，最后遍历主节点) public void suffixOrder() { if (rootStudent == null) { System.out.println(\"该树结构无任何元素\"); } else { this.rootStudent.suffixOrder(); } } public void deleteNode(int i) { if (this.rootStudent.getId() == i) { System.out.println(\"删除的是最顶层根节点，无法删除!\"); } else { this.rootStudent.deleteNode(i); } } } // 这里是个学生类的二叉树子节点 class ThreadStudentNode { private int id; private String name; private ThreadStudentNode left; private ThreadStudentNode right; // 这里需要设置两个成员变量， 来确定左右指针的类型是默认的子树，还是线索化设置的引用 // 这里如果默认是0就是默认的子树， 如果是1则表示是线索化设置的引用 private int leftType; private int rightType; public ThreadStudentNode(int id, String name) { this.id = id; this.name = name; } //删除 public void deleteNode_v1(int no) { //这里和遍历或者查找不一样哈， 因为如果是遍历，是不会返回的 //这里就只能默认只有一个 if (this.left != null && this.left.id == no) { this.left = null; return; } if (this.right != null && this.right.id == no) { this.right = null; return; } if (this.left != null) { this.left.deleteNode(no); } if (this.right != null) { this.right.deleteNode(no); } } public void deleteNode(int id) { if (this.left != null) { if (this.getLeft().getId() == id) { this.setLeft(null); return; } this.left.deleteNode(id); } if (this.right != null) { if (this.getRight().getId() == id) { this.setRight(null); return; } this.right.deleteNode(id); } } public ThreadStudentNode preOrderSearch(int id) { // 1, 先找根节点 System.out.println(\"开始找到的id为：\" + this.id); if (this.id == id) { return this; } // 2, 然后找左节点 ThreadStudentNode ThreadStudentNode = null; if (this.getLeft() != null) { ThreadStudentNode = this.getLeft().preOrderSearch(id); } // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了 if (ThreadStudentNode != null) { return ThreadStudentNode; } // 3, 最后找右节点 // 如果ThreadStudentNode 为null，说明还未找到 if (this.getRight() != null) { ThreadStudentNode = this.getRight().preOrderSearch(id); } // 这里为null说明为找到 return ThreadStudentNode; } public ThreadStudentNode infixSearch(int id) { // 1，先找左节点 ThreadStudentNode ThreadStudentNode = null; if (this.getLeft() != null) { ThreadStudentNode = this.getLeft().infixSearch(id); } // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了 // 左节点找到直接返回左节点 if (ThreadStudentNode != null) { return ThreadStudentNode; } // 2，然后找根节点 // 左节点没找到对比根节点 System.out.println(\"开始找到的id为：\" + this.id); if (this.id == id) { return this; } // 3，最后找右节点 // 如果根节点也没找到，找右节点 // 如果ThreadStudentNode 为null，说明还未找到 if (this.getRight() != null) { ThreadStudentNode = this.getRight().infixSearch(id); } // 这里为null说明为找到 return ThreadStudentNode; } public ThreadStudentNode suffixOrderSearch(int id) { // 1，先找左节点 // 左节点找到直接返回左节点 ThreadStudentNode ThreadStudentNode = null; if (this.getLeft() != null) { ThreadStudentNode = this.getLeft().suffixOrderSearch(id); } // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了 if (ThreadStudentNode != null) { return ThreadStudentNode; } // 2，然后找右节点 // 如果左节点没找到，找右节点 // 如果ThreadStudentNode 为null，说明还未找到 if (this.getRight() != null) { ThreadStudentNode = this.getRight().suffixOrderSearch(id); } // 如果右侧ok了直接返回就行了 if (ThreadStudentNode != null) { return ThreadStudentNode; } // 3，最后找根节点 // 如果左右都没找到， 再对比根节点 System.out.println(\"开始找到的id为：\" + this.id); if (this.id == id) { return this; } // 这里为null说明为找到 return ThreadStudentNode; } public void preOrder(){ // 先打印出当前 System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } public void suffixOrder() { if (this.left != null) { this.left.suffixOrder(); } if (this.right != null) { this.right.suffixOrder(); } System.out.println(this); } @Override public String toString() { return \"ThreadStudentNode{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } public ThreadStudentNode getLeft() { return left; } public void setLeft(ThreadStudentNode left) { this.left = left; } public ThreadStudentNode getRight() { return right; } public void setRight(ThreadStudentNode right) { this.right = right; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } } 4, 树的实际应用 堆排序 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它最好，最坏以及平均复杂度均为O(nlogn)，它是不稳定的排序 堆是具有以下性质的完全二叉树： 大顶堆：每个节点的值大于或者等于其左右孩子节点的值(变成顺序存储二叉树的时候，数组是从大到小的) 小顶堆：每个节点的值都小于或等于其左右孩子节点的值(变成顺序存储二叉树的时候，数组是从小到大的) 这个太难了，看了4个小时才差不多看明白 package im.bool.a09_tree; import java.util.Arrays; /** * @author : 不二 * @date : 2021/5/15-上午10:43 * @desc : 堆排序代码编写：构建大顶堆或者小顶堆 **/ public class a09_04_HeapSort { // 堆排序 public static void main(String[] args) { int arr[] = {4, 6,122, -5, 34, -111,78, 8, 5, 9}; heapSort(arr); } public static void heapSort(int[] arr) { System.out.println(\"堆排序\"); int temp = 0; // 首次构建大顶堆，需要从最右下，先同级往左， 然后再往上进行构建 // 这里i要大于等于0， 因为最上级根节点也需要调整 for (int i = arr.length / 2 - 1; i >= 0; i--) { adjustHeap(arr, i, arr.length); } System.out.println(Arrays.toString(arr)); // 首次构建大顶堆之后，先把最大值和数组最后一个元素互换。这样的话， 最大值在末位。 // 然后调用调整heap的方法，对n-1个元素处理，这样的话，最小值就会排序到最后一级 // 然后在重复和最后一个元素替换，在重复上述操作即可 for (int j = arr.length - 1; j > 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } System.out.println(Arrays.toString(arr)); } /** * 注意：这个方法并不是直接把树直接变成大顶堆或者小顶堆, 而是把给定的树变成最小值挪到下面。最大值挪到当前根节点(最大值不一定会挪到最上面) * 所以：第一次调节的时候， 需要从右往左，从下往上，依次调用该方法，这样的话， 就可以变成大顶堆了。 * 然后后续的把最值和最后一位数据交换后， 再对n-1个数据进行调整(只需要调整最上一个根节点即可，因为这个时候只有最上面一个值不符合大顶堆， * 下面的值会依次往上走，而根节点的这个值会交换到最下一级 * 好吧， 估计再重新看这段话的时候估计也看不明白) * @param arr 待调整的数组(按照二叉树的方式进行处理的) * @param i 根节点的位置 * @param length 对元素多少个数据进行调整。 * 因为顶堆建立之后， 会把最值放在边缘， * 这样的话，后续再做顶堆的时候，需要排序的数据就少了1个，依次做顶堆，然后放到后面， 这样数据就有序了 */ public static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; // 相当于左左叶子节点依次往下走， 会把大值往上走一级，最小值则直接放在最后 for (int k = 2 * i + 1; k temp) { // 说明叶子节点大于根节点 // 那么就把叶子节点的最大值往上走一级 arr[i] = arr[k]; // 这个是从k处接着往下走 i = k; } else { // 说明两个叶子节点都不大于根节点，那么就可以直接退出了 break; } // 如果走完之后， 说明当前i处就是把最小值放置的位置 arr[i] = temp; // 至此，最大值依次往上走， 最小值被挪至最后一行(最后一级) } } } 5, Huffman Tree(赫夫曼树) 给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度==wpl==:weighted path length达到最小，则称为最优二叉树，即是Huffman Tree 赫夫曼树是带权路径最短的树，权值较大的节点离根较近 构建HuffmanTree的步骤 把从小到大进行排序，每个元素是一个节点，每个节点看作是一个最简单的二叉树 取出跟节点权值最小的两个二叉树组成一棵新的二叉树，该新二叉树根节点的权值是前面两棵二叉树根节点权值加和 再将这棵新的二叉树，以根节点权值大小再次排序。 不断重复1，2，3步骤，直到数列中， 所有的数据都被处理，最后得到一棵二叉树 package im.bool.a10_huffmanTree; import java.util.ArrayList; import java.util.Collections; import java.util.List; /** * @author : 不二 * @date : 2021/5/15-下午7:30 * @desc : huffman树构建 **/ public class a10_01_HuffmanTree { public static void main(String[] args) { int[] arr = {13, 7, 8, 3, 29, 6, 1}; Node node = constructHuffmanTree(arr); node.preOrder(); } // 给定数组，构建huffman树 public static Node constructHuffmanTree(int[] arr) { // 1，先构造成Node数组 List nodeList = new ArrayList<>(); for (int i : arr) { nodeList.add(new Node(i)); } // 2, 根据方法直接排序 // 最后会剩下最上级root节点 while (nodeList.size() > 1) { Collections.sort(nodeList); // System.out.println(\"排序后数组为：\" + nodeList.toString()); // 3, 先取出根节点最小的两个最简树(其实就是从小到大排序后的前面两个Node) Node left = nodeList.get(0); Node right = nodeList.get(1); Node theRoot = new Node(left.value + right.value); theRoot.left = left; theRoot.right = right; // 因为这两个节点已经关联上二叉树，所以可以从数组中去掉了 nodeList.remove(left); nodeList.remove(right); nodeList.add(theRoot); } Node finalRoot = nodeList.get(0); return finalRoot; } } // 节点类,这里避免代码太多， 就不添加不必要的方法了 // 因为需要排序，需要实现Comparable接口 class Node implements Comparable { int value; Node left; Node right; public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } @Override public int compareTo(Node o) { // this.value写在前面表示从小到大排列 return this.value - o.value; } } Huffman Code(Huffman编码) 前缀编码 通过Huffman编码实现数据的压缩和解压缩 代码参考：im.bool.a11_huffmanCode 6, binarySortTree(BST:二叉排序树) 对于二叉排序树的任何一个非叶子节点， 要求：左子节点的值比当前节点的值小。右子节点的值比当前节点的值大 特别说明：如果有相同的值，可以将该节点放在左子节点或者右子节点，按照规则存放即可 二叉排序树特性：中序遍历的结果刚好是从小到大打印 如下代码显示了二叉排序树的创建，新增，删除节点等 package im.bool.a12_binarySortTree; import java.util.ArrayList; import java.util.List; /** * @author : 不二 * @date : 2021/5/16-下午2:29 * @desc : 二叉排序树demo演示 * 用二叉排序树进行排序的话， 80万数据， 快速排序大概150s，二叉排序树大概630s，二叉排序树比冒泡要好的多， **/ public class a12_BinarySortTreeDemo { public static void main(String[] args) { // 这不就可以直接当作排序来用了吗 // int[] arr = {7, 3, 10, 12, 5, 1, 9, -1, 2, 3, 7, 6}; // 80000万这个量级的数据好像不行了，跑不动了 /*int count = 80000000; int[] nums = new int[count]; for (int i = 0; i result = new ArrayList<>(); binarySortTree.infixOrderSort(result); long endTime = System.currentTimeMillis(); long duration = (endTime - startTime); System.out.println(\"排序耗时---\" + duration);*/ // int[] arr = {7, 3, 10, 12, 5, 1, 9, -1, 2, 3, 7, 6}; int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); for (int i : arr) { binarySortTree.add(new Node(i)); } // 二叉排序树的中序排列刚好是升序排列 System.out.println(\"中序遍历(升序)：\"); binarySortTree.infixOrder(); binarySortTree.delNode(2); binarySortTree.delNode(5); binarySortTree.delNode(9); binarySortTree.delNode(12); binarySortTree.delNode(7); binarySortTree.delNode(3); binarySortTree.delNode(10); System.out.println(); System.out.println(\"删除数据后中序遍历(升序)：\"); binarySortTree.infixOrder(); System.out.println(); System.out.println(\"根节点是：\" + binarySortTree.printRoot()); } } class BinarySortTree { private Node root; public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 删除一个节点 public void delNode(int value) { if (root == null) { return; } else { //删除一个节点: // 1，先找到该节点 Node node = search(value); if (node == null) { // 说明没有该节点可以直接返回 return; } // 先优化一点：因为已经找到节点， 但是如果整个二叉排序树只有一个节点，那么删除的必定是主根节点 // 直接把根节点设置为null即可 if (root.left == null && root.right == null) { root = null; return; } // 2, 再找到该节点的父节点 Node parentNode = searchParent(value); // 3，如果删除的节点node是叶子节点： // 先判断节点是左子节点还是右子节点，然后直接设置为null即可 if (node.left == null && node.right == null) { if (parentNode.left != null && parentNode.left.value == node.value) { parentNode.left = null; } else if (parentNode.right != null && parentNode.right.value == node.value) { parentNode.right = null; } } // 4, 先删除非叶子节点：先删除有两棵子树的情况： else if (node.left != null && node.right != null) { // 这种情况下，需要从删除节点的右子节点树中找到最小的值，并把最小值赋予node上(node的数据就被删除了，而且赋值后依然满足二叉排序树规则) // 如果不想从右子树找最小值，这里其实也可以从左子树找到最大值然后赋值到node上也一样 int min = delRightTreeMin(node.right); // 搞定！ node.value = min; } // 5, 最后只剩一种情况：就是非叶子节点， 但是只有一棵子树 else { // 这里有一个问题：如果删除一个只有一个叶子节点的根节点，那么因为根节点没有parentNode了，那么就会报错 /*if (node.left != null) { // 说明有的那棵子树是左子树 if (parentNode.left.value == node.value) { parentNode.left = node.left; } else { parentNode.right = node.left; } } else { // 说明是右子树 if (parentNode.left.value == node.value) { parentNode.left = node.right; } else { parentNode.right = node.right; } }*/ if (node.left != null) { if (parentNode != null) { // 说明有的那棵子树是左子树 if (parentNode.left.value == node.value) { parentNode.left = node.left; } else { parentNode.right = node.left; } } else { root = node.left; } } else { if (parentNode != null) { // 说明是右子树 if (parentNode.left.value == node.value) { parentNode.left = node.right; } else { parentNode.right = node.right; } } else { root = node.right; } } } } } /** * 返回以node为根节点的二叉排序树最小节点的值 * 并在该二叉排序树中删除最小的节点 * @param node * @return */ public int delRightTreeMin(Node node) { Node target = node; while (target.left != null) { target = target.left; } // 因为这个值肯定是最后的叶子节点，所以可以直接调用delNode方法 delNode(target.value); return target.value; } public Node search(int value) { if (root == null) { return null; } else { return this.root.search(value); } } public Node searchParent(int value) { if (root == null) { return null; } else { return this.root.searchParent(value); } } public void preOrder() { if (root == null) { System.out.println(\"为null\"); return; } this.root.preOrder(); } // 二叉排序树的中序排列刚好是升序排列 public void infixOrder() { if (root == null) { System.out.println(\"为null\"); return; } this.root.infixOrder(); } public void infixOrderSort(List result) { if (root == null) { System.out.println(\"为null\"); return; } this.root.infixOrderSort(result); } public Node printRoot() { return this.root; } } class Node { int value; Node left; Node right; // 删除节点需要先查找这个节点 public Node search(int value) { if (value == this.value) { return this; } else if (value = this.value && this.right != null) { return this.right.searchParent(value); } else { return null; } } } // 添加节点方法 public void add(Node node) { if (node == null) { System.out.println(\"被添加节点为null\"); return; } if (node.value \"); if (this.right != null) { this.right.infixOrder(); } } public void preOrder() { System.out.print(this + \" => \"); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } public void infixOrderSort(List result) { if (this.left != null) { this.left.infixOrderSort(result); } // System.out.print(this + \" => \"); result.add(this.value); if (this.right != null) { this.right.infixOrderSort(result); } } } 7, AVL树：平衡二叉树 又叫Self-Balancing Binary Search Tree 它是一棵空树或者它的左右两个子树的高度的绝对值不超过1 并且左右两棵子树都是一棵平衡二叉树 平衡二叉树常用的实现形式：==红黑树==，==AVL(算法)==，==替罪羊树==，==Treap==，==伸展树== 树旋转(左旋转/右旋转) 看代码 package im.bool.a13_avlTree; import java.util.List; /** * @author : 不二 * @date : 2021/5/22-上午10:59 * @desc : 平衡二叉树演示 **/ public class a13_AvlTreeDemo { public static void main(String[] args) { // int[] arr = {4, 3, 6, 5, 7, 8}; // int[] arr = {10, 12, 8, 9, 7, 6}; int[] arr = {10, 11, 7, 6, 8, 9}; AVLTree avlTree = new AVLTree(); for (int i : arr) { avlTree.add(new Node(i)); } System.out.println(\"中序遍历：\"); avlTree.infixOrder(); System.out.println(\"处理前：\"); System.out.println(\"树的高度为:\" + avlTree.root().height()); System.out.println(\"左子树的高度为:\" + avlTree.root().left.height()); System.out.println(\"右子树的高度为:\" + avlTree.root().right.height()); System.out.println(\"root:\" + avlTree.root()); System.out.println(\"root.left:\" + avlTree.root().left); System.out.println(\"root.right:\" + avlTree.root().right); } } class AVLTree { private Node root; public void add(Node node) { if (root == null) { root = node; } else { root.add(node); } } // 删除一个节点 public void delNode(int value) { if (root == null) { return; } else { //删除一个节点: // 1，先找到该节点 Node node = search(value); if (node == null) { // 说明没有该节点可以直接返回 return; } // 先优化一点：因为已经找到节点， 但是如果整个二叉排序树只有一个节点，那么删除的必定是主根节点 // 直接把根节点设置为null即可 if (root.left == null && root.right == null) { root = null; return; } // 2, 再找到该节点的父节点 Node parentNode = searchParent(value); // 3，如果删除的节点node是叶子节点： // 先判断节点是左子节点还是右子节点，然后直接设置为null即可 if (node.left == null && node.right == null) { if (parentNode.left != null && parentNode.left.value == node.value) { parentNode.left = null; } else if (parentNode.right != null && parentNode.right.value == node.value) { parentNode.right = null; } } // 4, 先删除非叶子节点：先删除有两棵子树的情况： else if (node.left != null && node.right != null) { // 这种情况下，需要从删除节点的右子节点树中找到最小的值，并把最小值赋予node上(node的数据就被删除了，而且赋值后依然满足二叉排序树规则) // 如果不想从右子树找最小值，这里其实也可以从左子树找到最大值然后赋值到node上也一样 int min = delRightTreeMin(node.right); // 搞定！ node.value = min; } // 5, 最后只剩一种情况：就是非叶子节点， 但是只有一棵子树 else { // 这里有一个问题：如果删除一个只有一个叶子节点的根节点，那么因为根节点没有parentNode了，那么就会报错 /*if (node.left != null) { // 说明有的那棵子树是左子树 if (parentNode.left.value == node.value) { parentNode.left = node.left; } else { parentNode.right = node.left; } } else { // 说明是右子树 if (parentNode.left.value == node.value) { parentNode.left = node.right; } else { parentNode.right = node.right; } }*/ if (node.left != null) { if (parentNode != null) { // 说明有的那棵子树是左子树 if (parentNode.left.value == node.value) { parentNode.left = node.left; } else { parentNode.right = node.left; } } else { root = node.left; } } else { if (parentNode != null) { // 说明是右子树 if (parentNode.left.value == node.value) { parentNode.left = node.right; } else { parentNode.right = node.right; } } else { root = node.right; } } } } } /** * 返回以node为根节点的二叉排序树最小节点的值 * 并在该二叉排序树中删除最小的节点 * @param node * @return */ public int delRightTreeMin(Node node) { Node target = node; while (target.left != null) { target = target.left; } // 因为这个值肯定是最后的叶子节点，所以可以直接调用delNode方法 delNode(target.value); return target.value; } public Node search(int value) { if (root == null) { return null; } else { return this.root.search(value); } } public Node searchParent(int value) { if (root == null) { return null; } else { return this.root.searchParent(value); } } public void preOrder() { if (root == null) { System.out.println(\"为null\"); return; } this.root.preOrder(); } // 二叉排序树的中序排列刚好是升序排列 public void infixOrder() { if (root == null) { System.out.println(\"为null\"); return; } this.root.infixOrder(); } public void infixOrderSort(List result) { if (root == null) { System.out.println(\"为null\"); return; } this.root.infixOrderSort(result); } public Node root() { return this.root; } } class Node { int value; Node left; Node right; /** * 对当前节点进行左旋转 */ private void leftRotate() { // 1，以当前节点的值创建新的节点 // 2, 把新节点的左子树设置成当前节点的左子树 // 3，把新节点的右子树设置成当前节点右子树的左子树 // 4，把当前节点(非新创建的节点哈)的值换成右子节点的值 // 5，把当前节点的左子树设置成新节点 // 6，把当前节点的右子树设置成右子树的右子树 // 1 Node newNode = new Node(this.value); // 2 newNode.left = this.left; // 3 newNode.right = this.right.left; // 4 this.value = this.right.value; // 5 this.left = newNode; // 6 this.right = this.right.right; } /** * 对当前节点进行右旋转 */ private void rightRotate() { // 1，以当前节点的值创建新的节点 // 2, 把新节点的右子树设置成当前节点的右子树 // 3，把新节点的左子树设置成当前节点左子树的右子树 // 4，把当前节点(非新创建的节点哈)的值换成左子节点的值 // 5，把当前节点的右子树设置成新节点 // 6，把当前节点的左子树设置成左子树的左子树 // 1 Node newNode = new Node(value); // 2 newNode.right = this.right; // 3 newNode.left = this.left.right; // 4 this.value = this.left.value; // 5 this.right = newNode; // 6 this.left = this.left.left; } public int leftHeight() { if (left == null) { return 0; } return left.height(); } public int rightHeight() { if (right == null) { return 0; } return right.height(); } // 返回以该节点作为根节点的树的高度 public int height() { return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; } // 删除节点需要先查找这个节点 public Node search(int value) { if (value == this.value) { return this; } else if (value = this.value && this.right != null) { return this.right.searchParent(value); } else { return null; } } } // 添加节点方法 public void add(Node node) { if (node == null) { System.out.println(\"被添加节点为null\"); return; } if (node.value 1) { // 注意：如果右子树里面：右子树的左子树比右子树的右子树高，那么需要先对右子树进行右旋转 if (right != null && right.leftHeight() - right.rightHeight() > 0) { this.left.rightRotate(); } leftRotate(); // 这里平衡了就必须直接返回 return; } // 如果左子树比右子树高， 需要右旋转 if (leftHeight() - rightHeight() > 1) { // 注意：如果左子树里面：左子树的右子树比左子树的左子树高，那么需要先对左子树进行左旋转 if (left != null && left.rightHeight() - left.leftHeight() > 0) { this.left.leftRotate(); } rightRotate(); } } public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.print(this + \" => \"); if (this.right != null) { this.right.infixOrder(); } } public void preOrder() { System.out.print(this + \" => \"); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } public void infixOrderSort(List result) { if (this.left != null) { this.left.infixOrderSort(result); } // System.out.print(this + \" => \"); result.add(this.value); if (this.right != null) { this.right.infixOrderSort(result); } } } 2-3树 2-3树是最简单的b树结构 2-3树的所有叶子节点都在同一层(B树的共同特点) 有两个节点的节点叫做二节点， 二节点要么没有子节点，要么有两个子节点 有三个节点的节点叫做三节点， 三节点要么没有子节点， 要么有三个子节点 2-3树是有二节点和三节点组成的树 2.4, 图结构 package im.bool.a14_graph; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.Map; /** * @author : 不二 * @date : 2021/5/22-下午3:17 * @desc : 图的代码演示 **/ public class a14_GraphDemo { public static void main(String[] args) { Graph graph = new Graph(8); // String[] vertex = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String[] vertex = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; // 先插入点 for (String s : vertex) { graph.insertVertex(s); } // 添加边, A-B(0,1), A-C(0,2), B-C(1,2), B-D(1,3), B-E(1,4) // A 0 // B 1 // C 2 // D 3 // E 4 /*graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1);*/ graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); // 显示邻接矩阵 graph.showGraph(); System.out.println(\"dfs深度遍历\"); graph.depthFirstSearch(); System.out.println(); System.out.println(\"bfs深度遍历\"); graph.broadFirstSearch(); } } class Graph { // 这里在额外添加一个map，保存vertext和其索引的关系 // private Map vertexMap; // 存储定点(我们这里认为每个点是一个字符串，也就是点的名字) private ArrayList vertexList; // 存储边(连接矩阵) private int[][] edges; // 一共有多少边 private int numOfEdges; private boolean[] isVisited; public Graph(int n) { edges = new int[n][n]; vertexList = new ArrayList(n); isVisited = new boolean[n]; } /** * * @param index：给定定点位置，获取该定点最临近的临接点(远近是按照点的插入顺序来确定的，早插入的就比较近(其实就是索引比较小的)) * @return 返回-1代表没有临接点 */ public int getFirstNeighbor(int index) { for (int j = 0; j 0) { return j; } } return -1; } /** * * @param v1: 该表点的位置X坐标 * @param v2：代表当前点Y坐标(找下一个， y+1就是下一个) * @return */ public int getNextNeighbor(int v1, int v2) { for (int j = v2 + 1; j 0) { return j; } } return -1; } /** * 图的深度优先遍历(Depth First Search) * * @param * i: 第一次传0， 然后后续根据遍历进行逐步往后遍历 * 这里有个潜在的内容：如果有一个点被加入， 那么该点一定和其他任何点有关系，要不然加到图中就咩有意义了 */ private void depthFirstSearch(boolean[] isVisited, int i) { // 拿到节点， 先打印出结果 System.out.print(getVertexValueByIndex(i) + \" ===> \"); // 将该节点设置为已访问 isVisited[i] = true; // 根据给定的位置，获取该位置点上的下一个点 int w = getFirstNeighbor(i); // 说明该点有临接点 while (w != -1) { // 说明找到临接点，而且该点并未被访问过 if (!isVisited[w]) { depthFirstSearch(isVisited, w); } // 如果找到了临接点， 但是该点被访问过了，那么需要找下一个临接点 w = getNextNeighbor(i, w); } // 说明当前点的所有对应位置均未找到未访问过的临接点 // 这个时候需要往上回溯找上面一个点的后续坐标(因为这里是给定i的，所以这个回溯需要放在另外的方法中:depthFirstSearch) } // 方法重载 public void depthFirstSearch() { // 使用前先初始化以免被其他干扰 isVisited = new boolean[getNumofVertex()]; for (int i = 0; i \"); isVisited[i] = true; queue.addLast(i); // 当队列中不为空的时候 while (!queue.isEmpty()) { // 把刚才添加进去的取出来，也就是头节点 u = (int) queue.removeFirst(); w = getFirstNeighbor(u); while (w != -1) { if (!isVisited[w]) { System.out.print(getVertexValueByIndex(w) + \" ===> \"); isVisited[w] = true; queue.addLast(w); } // 广度查询 w = getNextNeighbor(u, w); } } } public void broadFirstSearch() { // 使用前先初始化以免被其他干扰 isVisited = new boolean[getNumofVertex()]; for (int i = 0; i 2.5, 广义表 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/02-hanshunping/01-数据结构-02-非线形数据结构.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/02-hanshunping/02-算法01-常用的八大排序算法.html":{"url":"01-algthrim/02-hanshunping/02-算法01-常用的八大排序算法.html","title":"02-算法01-常用的八大排序算法","keywords":"","body":"1. 八大排序算法1.1. 1, 算法的基本概念1.2. 2, 八大排序算法基础1.2.1. 2.1, 排序算法分类1.2.2. 2.2, 时间复杂度1.2.3. 2.3, 平均时间复杂度和最坏时间复杂度1.3. 2.4, 八大排序算法1.3.1. 1, 冒泡算法1.3.2. 2, 快速排序(平分移动+迭代排序)-冒泡算法的优化1.3.3. 3, 选择排序1.3.4. 4, 插入排序1.3.5. 5, shell(希尔)排序-插入排序的优化1.3.6. 6, 归并排序1.3.7. 7, 基数排序(桶排序)1.3.8. 8, 堆排序[toc] 1. 八大排序算法1.1. 1, 算法的基本概念1.2. 2, 八大排序算法基础1.2.1. 2.1, 排序算法分类1.2.2. 2.2, 时间复杂度1.2.3. 2.3, 平均时间复杂度和最坏时间复杂度1.3. 2.4, 八大排序算法1.3.1. 1, 冒泡算法1.3.2. 2, 快速排序(平分移动+迭代排序)-冒泡算法的优化1.3.3. 3, 选择排序1.3.4. 4, 插入排序1.3.5. 5, shell(希尔)排序-插入排序的优化1.3.6. 6, 归并排序1.3.7. 7, 基数排序(桶排序)1.3.8. 8, 堆排序 1. 八大排序算法 1.1. 1, 算法的基本概念 程序=数据结构+算法 算法中先学习排序算法 排序也成为排序算法(sort algorithm)， 是将一组数据按照指定的顺序进行排列的过程 1.2. 2, 八大排序算法基础 1.2.1. 2.1, 排序算法分类 内部排序和外部排序 内部排序：将所有的需要处理的数据都加载到内存中进行排序处理 外部排序：数据量大或者其他原因， 无法把数据全部加载到内存中， 需要借助外部存储进行排序 1.2.2. 2.2, 时间复杂度 时间复杂度其实是渐进时间复杂度的简称，是指计算时间的一个趋势的复杂度 T(n)=n²+7n+6 与 T(n)=3n²+2n+2 : 时间复杂度都是：O(n²)。 用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n² 去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²) 常数阶O(1) int i=0; int j = 1; i++; j++; int m = i+j; 对数阶O(log2n) 说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) 。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) . int i=1; while(i 线性阶O(n) 说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 for(int i=0;i 线性对数阶O(nlog2n) 说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) for(m=1;m 平方阶O(n^2^) 说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(nn)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(mn) for(int i=0;i 立方阶O(n^3^) for(int i=0;i k次方阶O(n^k^) : 这里k>3 指数阶O(2^n^) 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2^)＜Ο(n^3^)＜ Ο(n^k^) ＜Ο(2^n^) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低 从图中可见，我们应该尽可能避免使用指数阶的算法 1.2.3. 2.3, 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。 1.3. 2.4, 八大排序算法 1.3.1. 1, 冒泡算法 相邻的两个进行比较，如果前者比后者大，那么就把大的移动到后面。 第一轮把最大的移动到最后一位 第二位把次大的移动到倒数第二位 依次进行，直到有序(n个数最大进行n-1轮即可有序) a06_01_Bubble_basic package im.bool.a06_sort_algrithm; /** * #Author : ivanl001 * #Date : 2020/2/24 9:53 AM * #Desc : 排序算法之冒泡推算过程： * 这个过程中有一个优化过程：如果经过一轮冒泡，顺序完全没有变动，那么后续就不需要进行了，因为这个时候顺序已经排好了 **/ public class a06_01_Bubble_basic { public static void main(String[] args) { int[] nums = {3, 9, -1, -2, 10}; int temp; System.out.println(\"第一次冒泡：\"); for (int i=0;i nums[i+1]) { temp = nums[i]; nums[i] = nums[i + 1]; nums[i+1] = temp; } } for (int i = 0; i nums[i+1]) { temp = nums[i]; nums[i] = nums[i + 1]; nums[i+1] = temp; } } for (int i = 0; i nums[i+1]) { temp = nums[i]; nums[i] = nums[i + 1]; nums[i+1] = temp; } } for (int i = 0; i nums[i+1]) { temp = nums[i]; nums[i] = nums[i + 1]; nums[i+1] = temp; } } for (int i = 0; i a06_02_Bubble package im.bool.a06_sort_algrithm; import jdk.internal.org.objectweb.asm.tree.FrameNode; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/24 5:58 PM * #Desc : 冒泡排序算法：两次循环实现 **/ public class a06_02_Bubble { public static void main(String[] args) { /*int[] nums = {9, -2, -1, 3, 10, 100, -3, 3, 4, 20}; bubbleSort(nums); for (int j = 0; j nums[j + 1]) { temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; isOrdered = false; } } /*for (int j = 0; j a06_03 如果是向左冒泡，那么左边的边界需要依次变大 如果是向右冒泡， 那么右边的边界需要依次变小 // 如果是向左冒泡，那么左边的边界需要依次变大 public static void bubbleSort(int[] arr) { for (int i = 0; i i; j--) { if (arr[j] arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; } } } } 1.3.2. 2, 快速排序(平分移动+迭代排序)-冒泡算法的优化 快速排序思路 首先以中间一个数字为基准，把该数右侧大于该数的移至该数左侧，把该数左侧大于数的移至该数右侧。这样大于该数的数字都在右侧，小于该数的都在该数左侧。 接着再使用迭代算法, 依次对左侧的进行相同方法的移动。 接着再使用迭代算法, 依次对右侧的进行相同方法的移动。 当迭代结束，该数组数字即是有序 a06_09_Quick package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/27 7:22 PM * #Desc : 快速排序法，这个是冒泡排序算法的优化。和冒泡算法属于同一排序算法 * 快排的话， 在n值比较大的时候就比shell要好很多。 * 如果都在8万数据的话， shell大概21ms，快排大概67ms * 如果是8000万数据， shell大概41s，快排只需要12s **/ public class a06_09_Quick { public static void main(String[] args) { /*int[] nums = {-9, 78, 0, 23, -567, 70}; quickSort(nums, 0, nums.length - 1); System.out.println(Arrays.toString(nums));*/ int[] nums = new int[80000]; for (int i = 0; i pivot) { r -= 1; } // 当r= r) { break; } // 交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; // 这两步必不可少。因为如果当前的值和中轴值一样，那么这个地方要跳过，要不然就是死循环，因为交换后，值不变，然后继续交换，继续相等 if (arr[l] == pivot) { r--; } if (arr[r] == pivot) { l++; } } // 这个地方如果不添加，会死循环，因为跳不出来 if (l == r) { l += 1; r -= 1; } // 走完前面的说明比中间值小或相等的都会挪到左边， 比中间值大或相等的都会挪到右边. if (left l) { quickSort(arr, l, right); } } } ​ 1.3.3. 3, 选择排序 大体思路： 第一轮从数组中选取最小的数据，放在第一位。 第二轮从第一个之后的那些数中选择最小的，放在第二位 第三轮从第二个之后的那些数中选取最小的，放在第三位 直至放到倒数第二位为止。 n个数字经过(n-1)轮后，即可保证有序 a06_03_Select_basic package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/24 7:57 PM * #Desc : 选择排序基础: 这里是第一轮从第二个数开始，如果发现比第一个数小，先标记为最小，然后往后看，直到最后，那么把第一个数和标记的最小数互换 * 第二轮从第三个数开始，如果发现比第一个数小，先标记为最小，然后往后看，直到最后，那么把第二个数和标记的最小数互换 * 依次下去，直至最后一个数字 **/ public class a06_03_Select_basic { public static void main(String[] args) { int[] nums = {3, 9, -1, -2, -10}; int min = nums[0]; int index = 0; //第一轮 min = nums[0]; index = 0; for (int i = 0 + 1; i nums[i]) { min = nums[i]; index = i; } } if (index > 0) { nums[index] = nums[0]; nums[0] = min; } System.out.println(Arrays.toString(nums)); //第二轮 min = nums[1]; index = 1; for (int i = 1 + 1; i nums[i]) { min = nums[i]; index = i; } } if (index > 1) { nums[index] = nums[1]; nums[1] = min; } System.out.println(Arrays.toString(nums)); //第三轮 min = nums[2]; index = 2; for (int i = 2 + 1; i nums[i]) { min = nums[i]; index = i; } } if (index > 2) { nums[index] = nums[2]; nums[2] = min; } System.out.println(Arrays.toString(nums)); //第四轮 min = nums[3]; index = 3; for (int i = 3 + 1; i nums[i]) { min = nums[i]; index = i; } } if (index > 3) { nums[index] = nums[3]; nums[3] = min; } System.out.println(Arrays.toString(nums)); } } a06_04_Select package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/24 8:31 PM * #Desc : TODO **/ public class a06_04_Select { public static void main(String[] args) { /*int[] nums = {3, 9, -1, -2, -10, 30, -5, 100, 30, 3, -4, 33}; selectSort(nums); System.out.println(Arrays.toString(nums));*/ int[] nums = new int[80000]; for (int i = 0; i nums[j]) { min = nums[j]; index = j; } } if (index > i) { nums[index] = nums[i]; nums[i] = min; } } } } 1.3.4. 4, 插入排序 1，第一轮把第二个数和第一个比较， 如果比第一个小， 那么把第一个后移一位，然后把第二个数赋值到第一位上 2，第二轮把第三个数和第二个数比较，如果比第二个小，那么把第二个数后移一位，然后再和第一个数比较，如果还比第一个数小(否则把第三个数赋值到第二位上)，再把第一个数后移一位，把第三个数赋值到第一位上。 3，依次执行如上逻辑 4，n个数字经过(n-1)轮插入，即可保证有序 注意：插入是先在前面的数据中找到应该插入的位置，最后才会插入 这个和冒泡有点类似， 不过冒泡是先替换，然后再冒泡。插入时先找到最后位置，最后再替换。 插入的重点是: 把后面的一次往后移动一位，空出需要插入的，然后插入即可 a06_05_Insert_basic package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/25 9:24 AM * #Desc : 插入排序算法的推导过程 **/ public class a06_05_Insert_basic { public static void main(String[] args) { int[] nums = {3, 9, -1, -2, 10}; //插入排序思路： /** * 1，第一轮把第二个数和第一个比较， 如果比第一个小， 那么把第一个后移一位，然后把第二个数赋值到第一位上 * 2，第二轮把第三个数和第二个数比较，如果比第二个小，那么把第二个数后移一位，然后再和第一个数比较，如果还比第一个数小(否则把第三个数赋值到第二位上)，再把第一个数后移一位，把第三个数赋值到第一位上。 * 3，依次执行如上逻辑 * 4，n个数字经过(n-1)轮插入，即可保证有序 */ //即将被插入的数字 int insertValue = nums[1]; //这个是要找的待插入序号 int indexToInsert = 1 - 1; while (indexToInsert >= 0 && insertValue = 0 && insertValue = 0 && insertValue = 0 && insertValue a06_06_Insert package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/25 10:11 AM * #Desc : 插入排序法 **/ public class a06_06_Insert { public static void main(String[] args) { /*int[] nums = {3, 9, -1, -2, 10, -3, 0}; insert(nums); System.out.println(Arrays.toString(nums));*/ int[] nums = new int[80000]; for (int i = 0; i = 0 && insertValue 1.3.5. 5, shell(希尔)排序-插入排序的优化 shell排序是插入排序的优化，以减少数据插入之前为了找到插入位置而可能后移次数过多的问题 shell排序的时候有两种方式： 1，交换法。直接进行交换， 速度慢 2，移动法，先移动，而不是直接交换。速度快,超级快！80万只需要20ms左右。 ==下面图中有点说的好像不对：分组之后排序的时候， 用的应该不是插入排序，而是冒泡排序吧== 不过有点需要留意： ==shell排序的时候循环次数比插入排序循环次数要多，只不过shell排序的插入次数少了， 所以才快的== 这个时间复杂度是n*logn,相对n的平方还是要小的 a06_08_Shell_01_exchange(并不是shell排序) package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/25 11:55 AM * #Desc : 希尔排序-插入排序的优化算法: 直接交换，其实不是很好，效率有限 * 希尔排序的时间复杂度是nlogn,比n^2要好一些 **/ public class a06_08_Shell_01_exchange { public static void main(String[] args) { int[] nums = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; shellSort(nums); /*int[] nums = new int[80000]; for (int i = 0; i 0; gap /= 2) { //第一轮排序，将10个数据分成了5组 for (int i = gap; i = 0; j -= gap) { if (nums[j] > nums[j + gap]) { nums[j] = nums[j + gap]; nums[j + gap] = temp; } } } //System.out.println(\"第 \" + (m++) + \" 轮：\" + Arrays.toString(nums)); } } } a06_08_Shell_02_move package im.bool.a06_sort_algrithm; import sun.plugin2.ipc.windows.WindowsIPCFactory; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/25 11:55 AM * #Desc : 希尔排序-插入排序的优化算法: 采用希尔排序移动法 **/ public class a06_08_Shell_02_move { public static void main(String[] args) { /*int[] nums = {12, -10, 100, 8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; shellSort01(nums); System.out.println(Arrays.toString(nums));*/ int[] nums = new int[80000]; for (int i = 0; i 0; gap /= 2) { //第一轮排序，将10个数据分成了5组 for (int i = gap; i = 0) && temp 1.3.6. 6, 归并排序 a06_10_Merge package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/27 8:04 PM * #Desc : 归并排序算法，这个是分治算法其中一种 **/ public class a06_10_Merge { public static void main(String[] args) { /*int[] nums = {8, 4, 5, 7, 1, 3, 6, 2}; int[] temp = new int[nums.length]; mergeSort(nums, 0, nums.length - 1, temp); System.out.println(Arrays.toString(nums));*/ int[] nums = new int[800000000]; for (int i = 0; i 1.3.7. 7, 基数排序(桶排序) ==这个时间复杂度是非常稳定的, O(n*k)== 基数排序思想： 第一轮：根据个位数字放进0-9不同的桶中 第二轮： 在第一轮的顺序下，根据十位数放进0-9不同的桶中 第三轮：在第二轮的顺序下，根据百位数放进不同的桶中 ... 直到最后一轮根据最大一位上的数字进行完毕， 则序列即可保证有序 a06_11_RadixSort_basic package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/29 9:48 AM * #Desc : 基数排序：0-9个不同的桶，然后分别按照个位，十位，百位数，。。。等等你放进不同的桶中，具体看代码 * 基数排序需要10倍额外空间，所以是空间换时间的经典案例 **/ public class a06_11_RadixSort_basic { public static void main(String[] args) { int[] nums = {53, 3, 542, 748, 14, 214}; radixSort(nums); } public static void radixSort(int[] nums) { int[][] bucket = new int[10][nums.length]; int[] positions = new int[10]; //第一轮， 根据每个元素的个位元素进行排序 for (int i = 0; i a06_12_RadixSort package im.bool.a06_sort_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/2/29 9:48 AM * #Desc : 基数排序：0-9个不同的桶，然后分别按照个位，十位，百位数，。。。等等你放进不同的桶中，具体看代码 * 基数排序需要10倍额外空间，所以是空间换时间的经典案例 * 如果是800万个数字，那么需要空间大概是： **/ public class a06_12_RadixSort { public static void main(String[] args) { /*int[] nums = {53, 3, 542, 748, 14, 214}; radixSort(nums);*/ int[] nums = new int[8000000]; for (int i = 0; i max) { max = nums[i]; } } int theLength = (max + \"\").length(); int[][] bucket = new int[10][nums.length]; int[] positions = new int[10]; //这里比较牛，n*10直接计算出来了 for (int k = 0, n = 1; k 1.3.8. 8, 堆排序 该部分内容参考数据结构-树部分 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/02-hanshunping/02-算法01-常用的八大排序算法.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/02-hanshunping/02-算法02-常用的查找算法.html":{"url":"01-algthrim/02-hanshunping/02-算法02-常用的查找算法.html","title":"02-算法02-常用的查找算法","keywords":"","body":"1. 常用的查找算法1.1. 1, 正常的顺序查找1.1.1. a07_01_NormalSearch1.2. 2, 二分查找算法1.2.1. a07_02_BinarySearch1.3. 3, 插值查找算法1.3.1. a07_03_InterpolationSearch1.4. 4, 斐波那契查找算法1.4.1. 基本介绍1.4.2. 工作原理1.4.3. a07_04_FibonacciSearch[toc] 1. 常用的查找算法1.1. 1, 正常的顺序查找1.1.1. a07_01_NormalSearch1.2. 2, 二分查找算法1.2.1. a07_02_BinarySearch1.3. 3, 插值查找算法1.3.1. a07_03_InterpolationSearch1.4. 4, 斐波那契查找算法1.4.1. 基本介绍1.4.2. 工作原理1.4.3. a07_04_FibonacciSearch 1. 常用的查找算法 1.1. 1, 正常的顺序查找 1.1.1. a07_01_NormalSearch ==就是遍历，没啥内容== package im.bool.a07_search_algrithm; /** * #Author : ivanl001 * #Date : 2020/2/29 6:06 PM * #Desc : 正常的顺序查找 **/ public class a07_01_NormalSearch { public static void main(String[] args) { int[] nums = {1, 9, 11, -1, 35, 89}; int i = normalSearch(nums, -1); System.out.println(i); } public static int normalSearch(int[] nums, int value) { for (int i = 0; i 1.2. 2, 二分查找算法 1.2.1. a07_02_BinarySearch 有序数组中查找才有意义 注意：迭代的时候，binarySearch01(nums, left, midIndex-1, findValue)， 需要把midIndex左移一位或者右移一位 package im.bool.a07_search_algrithm; import java.util.ArrayList; import java.util.List; /** * #Author : ivanl001 * #Date : 2020/3/1 6:31 PM * #Desc : 二分查找算法 **/ public class a07_02_BinarySearch { public static void main(String[] args) { int[] nums = {1, 8, 10, 89, 89, 89, 89, 89, 89, 1000, 1234}; // int i = binarySearch(nums, 0, nums.length - 1, 89); // System.out.println(i); List integers = binarySearch01(nums, 0, nums.length - 1, 89); System.out.println(integers); } //如果有多个findValue在数组中，本方法就只能找出一个 public static List binarySearch01(int[] nums, int left, int right, int findValue) { //这里可以优化一下，如果小于最小数或者大于最大数，或者left > right，即可提前终止 if (findValue > nums[nums.length - 1] || findValue right) { return null; } int midIndex = (left+right)/2; int midValue = nums[midIndex]; if (left > right) { return null; } if (midValue > findValue) { return binarySearch01(nums, left, midIndex-1, findValue); } else if (midValue result = new ArrayList(); //然后再往左边找 for (int i = midIndex-1; i >= left; i--) { if (nums[i] == findValue) { result.add(i); } else { break; } } //先往右边找 for (int i = midIndex; i right，即可提前终止 if (findValue > nums[nums.length - 1] || findValue right) { return -1; } int midIndex = (left+right)/2; int midValue = nums[midIndex]; if (left > right) { return -1; } if (midValue > findValue) { return binarySearch(nums, left, midIndex-1, findValue); } else if (midValue 1.3. 3, 插值查找算法 1.3.1. a07_03_InterpolationSearch ==差值查找算法其实就是二分查找的比例化== ==int midIndex = left + (right-left)*(findValue-nums[left])/(nums[right]-nums[left]);== package im.bool.a07_search_algrithm; import java.util.ArrayList; import java.util.List; /** * #Author : ivanl001 * #Date : 2020/3/1 7:05 PM * #Desc : 插值查找算法：二分查找算法有一个问题：如果一个八万的数组，查找的数据是第一个，那么需要从中间开始计算查找。这样就会有很多无用的查找。 **/ public class a07_03_InterpolationSearch { public static void main(String[] args) { int[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}; List integers = interpolationSearch(nums, 0, nums.length - 1, 15); System.out.println(integers); } public static List interpolationSearch(int[] nums, int left, int right, int findValue){ System.out.println(\"ivanl0001\"); //这里可以优化一下，如果小于最小数或者大于最大数，或者left > right，即可提前终止 //注意：插入排序一定要有findValue nums[nums.length - 1], 要不然查询的数巨大，那么midIndex直接就过了 if (findValue > nums[nums.length - 1] || findValue right) { return null; } //插入算法和二分查找算法最根本的区别就是中间值的计算 //int midIndex = (left+right)/2; int midIndex = left + (right-left)*(findValue-nums[left])/(nums[right]-nums[left]); int midValue = nums[midIndex]; if (left > right) { return null; } if (midValue > findValue) { return interpolationSearch(nums, left, midIndex-1, findValue); } else if (midValue result = new ArrayList<>(); //然后再往左边找 for (int i = midIndex - 1; i >= left; i--) { if (nums[i] == findValue) { result.add(i); } else { break; } } //先往右边找 for (int i = midIndex; i 1.4. 4, 斐波那契查找算法 ==这个算法和二分查找及插值查找算法的不同的地方依然是中间值的逻辑不一样== https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/08/04.html#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86 1.4.1. 基本介绍 黄金分割 点是指把一条 线段 分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近视值是 0.618。由于按此比例设计的造型十分美丽，因此称为 黄金分割，也称为 中外比。这是一个神奇的数字，会带来意想不到的效果。 简单说，两条线的比例为 1:1.618，比如上图的头和身体的比例、鼻子和嘴巴下巴的比例 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的 两个相邻数的比例，无限接近 黄金分割值 0.618 简单说： 3/2=1.5 、5/3=1.667、8/5=1.6、13/8=1.625 这样看来，他们的比例值是无限接近的 1.618 的 1/2=0.5 、3/5=0.6、5/8=0.625、8/13=0.6125 这样看，他们的比例值是无限接近 0.618 的 1.4.2. 工作原理 与前两种（二分查找/插值查找算法）类似，只是改变了 mid 值 要从这个数组 arr = {1, 8, 10, 1000} 中查找数值 1000 斐波那契数列：{1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 1. 在斐波那契数列中找到符合这个数组长度的数值，如果没有，则找最近的一个 arr.length = 4, 在斐波那契数列中，没有 4 这个值，最近的一个是数值 5 ，index = 4 那么 k = 4 2. 要将原数组的长度扩充为这个 k 对应的数值 5，多余出来的 1 个数字用原数组 arr 的最后一个值填充 也就是： arr = {1, 8, 10, 1000} 扩充成如下 newArr = {1, 8, 10, 1000,1000} 3. 计算 mid 值 他的公式是 mid = low + F(k-1) -1 怎么理解呢？由上述所知，k = 4， {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } ↑ ↑ k ↑ k-1 k-2 斐波那契数列的特性是除了相邻数的比例是无限接近黄金分割值，还有一个特性是：相邻的两个数相加等于后一个数 就如上所述： 2 + 3 = 5 ，3 + 5 = 8；那么其中变量解释如下： mid ：就是我们要对比的值索引 low：该线段的最左端 F(k-1) 和 F(k-2)：分别表示这个数组个数左右两端的个数各是多少 那么 arr = {1, 8, 10, 1000} 的长度是 4，补充为斐波那契数列中的值后，新的数组长度是 5 k = 4 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 当 low = 0 时：mid = 0 + 3 - 1 = 2 当 low = 1 时：mid = 1 + 3 - 1 = 3 当 low = 2 时：mid = 2 + 3 - 1 = 4 当 low = 3 时：mid = 3 + 3 - 1 = 5 , 此时新数组长度为 5，最大下标为 4，已经超过该数组最大个数了，可以认为没有找到。 上面的验证是验证这个公式是否有效，至少不会出现数组越界的情况 那么再来推导验证下改变 k 的值，上面的 k = 4 当 k = 3 ，low = 0 ： mid = 0 + 2 -1 = 1 当 k = 2 ，low = 0 ： mid = 0 + 1 -1 = 0 当 k = 1 ，low = 0 ： mid = 0 + 1 -1 = 0 可以看到移动其中的 k 也是不会导致数组越界的。 那么再来看，k、k-1、k-2 有啥作用 arr = {1, 8, 10, 1000} 扩充成如下 newArr = {1, 8, 10, 1000,1000} {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } ↑ ↑ k ↑ k-1 k-2 扩充后的数组长度为 5 - - - - - 这一条线的长度为 5 ，也就是 k = 4 ↑ 左侧长度为 2 右侧长度为 3 Copied! 那么再来看下面的图： 斐波那契数列性质 F[k] = F[k-1] + F[k-2] 由以上性质可以得到上图的组合: F[k]-1 = (F[k -1] -1) + (F[k-2] -1) + 1 上图的公式 F[k - 1] - 1 + 中间 mid 占用 1 个位置 + F[k - 2] -1 + 1 个位置 就是这个数组的所有元素个数。 那么说明：只要顺序表的长度为 F[k]-1，则可以将该表分成 长度为 F[k-1]-1 和 F[k-2]-1 两段，如上图所示 那么中间值则为：mid = low + F[k-1]-1 上面说了这么多，其实也并没有说明白他的这个求中间值的公式为什么是这样，只是得到了最重要的几个信息： 求中间值是通过斐波那契数列来计算的 原始数组和斐波那契数列的关系是： 原始数组的长度必须扩充至斐波那契数列中某一个值的长度 因为可以通过斐波那契数列的性质，将这一个扩充数组分成黄金分割的两段 分成两段后，就可以查找中间值，而这个中间值则可称为黄金分割点 查找该点，是否是所要查找的值，如果不是，则根据大小，可继续将某一段继续分割，查找他的黄金分割点 k：进行 k 的减少或增加，必然可以根据斐波那契数列的特性，将数列分成两段 好了，个人理解差不多就只能这样了，下面看一遍代码实现，你就明白了，只能感叹数学之美。 1.4.3. a07_04_FibonacciSearch package im.bool.a07_search_algrithm; import java.util.Arrays; /** * #Author : ivanl001 * #Date : 2020/3/5 8:16 PM * #Desc : 斐波那契查找算法其实就是把原来的二分改为黄金分，这里我就不写代码了 **/ public class a07_04_FibonacciSearch { // 超过45的话, 就基本会超过int的最大值 public static int maxFibSize = 45; public static void main(String[] args) { int[] nums = {1, 8, 10, 34, 88, 89, 1000, 1234}; // int[] nums = {1, 8, 9}; int i = fibonacciSearch(nums, 89); System.out.println(\"对应的索引是:\" + i); if (i != -1) { System.out.println(\"对应的值是:\" + nums[i]); } /*int[] fib = fib(); System.out.println(Arrays.toString(fib));*/ } // 使用斐波那契查找算法，需要先设置好斐波那契数列 public static int[] fib() { int[] f = new int[maxFibSize]; int f0 = 1; int f1 = 1; f[0] = f0; f[1] = f1; int i=2; while (i f[k] - 1) { k++; } // 因为当前数组个数可能是比f[k]-1是小的，所以拼接 int[] temp = Arrays.copyOf(nums, f[k]); for (int i = rightIndex + 1; i temp[mid]) { leftIndex = mid + 1; k -= 2; } else { // rightIndex 是需要查找的最右侧。但是mid有可能大于rightIndex，因为右侧有填充 if (mid var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/02-hanshunping/02-算法02-常用的查找算法.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "},"01-algthrim/02-hanshunping/02-算法03-程序员常用的十种算法.html":{"url":"01-algthrim/02-hanshunping/02-算法03-程序员常用的十种算法.html","title":"02-算法03-程序员常用的十种算法","keywords":"","body":"1. 程序员常用的十种算法1.1. 1, 二分查找算法1.2. 2, 分治算法1.3. 3, 动态规划算法1.4. 4, KMP算法1.5. 5, 贪心算法1.6. 6, 普里姆算法1.7. 7, 克鲁斯卡尔算法1.8. 8, Dijkstra算法1.9. 9, Floyd算法1.10. 10, 骑士周游(马踏棋盘)算法[toc] 1. 程序员常用的十种算法1.1. 1, 二分查找算法1.2. 2, 分治算法1.3. 3, 动态规划算法1.4. 4, KMP算法1.5. 5, 贪心算法1.6. 6, 普里姆算法1.7. 7, 克鲁斯卡尔算法1.8. 8, Dijkstra算法1.9. 9, Floyd算法1.10. 10, 骑士周游(马踏棋盘)算法 1. 程序员常用的十种算法 1.1. 1, 二分查找算法 二叉树中已经使用递归的方式实现了二分查找算法 这里用非递归方式编写 package im.bool.a15_ten_algrithm; /** * @author : 不二 * @date : 2021/5/22-下午7:47 * @desc : 二分查找算法 **/ public class a15_01_BinarySort { public static void main(String[] args) { int[] arr = {1, 3, 8, 12, 123, 500, 2333, 8888}; int target = 123; int i = binarySearchNoRec(arr, target); System.out.println(\"非递归的二分查找算法查找结果索引是:\" + i); int j = binarySearch(arr, target); System.out.println(\"递归的二分查找算法超找结果索引是:\" + j); } /** * 这里进行方法重载方便调用 * @param arr 待查找数组 * @param target 查找目标值 * @return */ private static int binarySearch(int[] arr, int target) { return binarySearch(arr, target, 0, arr.length-1); } /** * 使用递归的方式进行二分查找算法 * @param arr 待查找数组 * @param target 查找目标值 * @param leftIndex 查找给定左侧边界 * @param rightIndex 查找给定右侧边界 * @return */ private static int binarySearch(int[] arr, int target, int leftIndex, int rightIndex) { // 这里有一个优化：如果查找的值小于最左值，或者大于最右值，那么可以直接跳出 if (target arr[rightIndex]) { return -1; } // 这里可以和上面合并 if (leftIndex > rightIndex) { return -1; } int midIndex = (leftIndex + rightIndex) / 2; if (arr[midIndex] == target) { return midIndex; } // 这里说明中间值小于目标值，目标值在右半部分 else if (arr[midIndex] arr[rightIndex]) { return -1; } // 这里需要有等于，要不然可能是最后一轮left=right的时候， 刚好相等， 就找不到了 while (leftIndex 1.2. 2, 分治算法 分而治之 把大问题分解成两个或者更多类似的小问题直接求解，原问题的解即是子问题的合并 分治算法的案例：快速排序， 归并排序，傅立叶变换 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线形时间选择 最接近点对问题 循环赛日程表 汉诺塔 https://www.mathsisfun.com/games/towerofhanoi.html 不论多少个盘， 只需要看成两个盘即可。 package im.bool.a15_ten_algrithm; /** * @author : 不二 * @date : 2021/5/22-下午8:29 * @desc : 分治算法案例-汉诺塔案例 **/ public class a15_02_DivideAndConquerDemo { public static void main(String[] args) { hanoiTower(4, \"left\", \"mid\", \"right\"); } /** * 分治算法解决汉诺塔方案 * @param topN: 待排序的盘数量 * @param from * @param inner * @param to */ private static void hanoiTower(int topN, String from, String inner, String to) { // System.out.println(\"topN是 \" + topN + \" ,from是 \" + from + \" ,inner是 \" + inner + \" ,to是 \" + to); if (topN == 1) { System.out.println(\"第1个盘从 \" + from + \" -> \" + to); } else { // 如果我们有n >= 2 的情况， 我们总是可以看作是一共两个盘： // 第一个盘是最下面的那个盘 第二个盘是其他所有的盘 // 需要做的是： // 1，先把第二个盘(其他所有的盘) : from -> inner 相当于把前面的移动到中间柱子 hanoiTower(topN-1, from, to, inner); // 2，把第一个盘(最下盘) ：最下的移动到to柱子上 System.out.println(\"第\" + topN + \"个盘从 \" + from + \" -> \" + to); // 3，把第二个盘(其他所有的盘): inner -> to, 相当于把中间柱子上的内容移动到目标柱子上 hanoiTower(topN - 1, inner, from, to); } System.out.print(\"\"); } } 1.3. 3, 动态规划算法 package im.bool.a15_ten_algrithm; import java.util.Arrays; /** * @author : 不二 * @date : 2021/5/23-下午1:47 * @desc : 动态规划代码编写-背包问题 **/ public class a15_03_DynamicProgramming { public static void main(String[] args) { int[] weights = {1, 4, 3}; int[] values = {1500, 3000, 2000}; // 这里是一共多少个物品 int nums = weights.length; // 限定背包的最大容量 int maxWeight = 4; // 这里用一个数组表示：前n个商品最大在最大容量问weight的时候最大的价值是多少 // valueArr[3]表示前3个商品， valueArr[3][2]表示前三个商品在最大重量为2的时候的最大价值是多少，方便后续计算的时候使用 int[][] valueArr = new int[nums + 1][maxWeight + 1]; // 先把一共有0个商品的情况默认设置成0，因为商品个数为0，不论背包容量多大，最大价值都是0 // 然后把背包最大重量为0的设置成默认值， 以为如果背包最大容量为0，不论多少个商品， 最大价值也都是0 // 设置最大容量为0的情况 // 当前这里不设置也没关系，因为默认是0，不过为了流程清晰，这里还是设置一下 for (int i = 0; i maxW) { valueArr[i][maxW] = valueArr[i - 1][maxW]; } // 说明最后一个物品的重量未超过包的最大容量 // 那么这个时候会有两种情况： // 第一：装下该商品的价值， 并加上剩余重量的最大价值求出一个价值 // 第二：不装下商品你， 算出：同等重量下：不装该商品的最大假期， 其实就是上一行同一列的值。 // 只有这两种情况，那么求出两个价值中的最大值即是最大该点的最大价值 else { // 第一种情况：values[i-1] + valueArr[i-1][maxW-weights[i-1]] // 第二种情况：valueArr[i - 1][maxW] // 不过有点需要注意：values以及weights里面的索引会比valueArr少一个， 因为valueArr里面考虑没有任何商品的情况和没有任何重量的情况 // valueArr[i][maxW] = Math.max(values[i-1] + valueArr[i-1][maxW-weights[i-1]], valueArr[i - 1][maxW]); // 这里通过判断来设置结果值，方便记录商品放置情况到goodsInfo中 if (values[i - 1] + valueArr[i - 1][maxW - weights[i - 1]] >= valueArr[i - 1][maxW]) { valueArr[i][maxW] = values[i - 1] + valueArr[i - 1][maxW - weights[i - 1]]; // 只需要在这里记录即可，因为这里才是真正的设置的地方，下面的那个只是往前回溯。 goodsInfo[i][maxW] = 1; } else { valueArr[i][maxW] = valueArr[i - 1][maxW]; } } } } // 打印结果方便观察 for (int[] theValues : valueArr) { System.out.println(Arrays.toString(theValues)); } // 这张表里记录了在最大值，前n个商品的时候， 拿哪些东西 for (int[] info : goodsInfo) { System.out.println(Arrays.toString(info)); } // 先判断最后一个：如果最后一个是1，那么最后一个一定是被放入了， 再根据重量，一次求出其他放入的商品即可 // m这里是前n件商品 int m = goodsInfo.length - 1; int n = goodsInfo[0].length -1; // 这里好巧妙啊，艹，太牛逼了 while (m > 0 && n > 0) { if (goodsInfo[m][n] == 1) { System.out.println(\"第 \" + m + \" 个商品放入了\"); // 这个背包已经放入了， 那么剩下的哪些背包被放入的话需要根据重量依次求解 n -= weights[m - 1]; } m--; } } } 1.4. 4, KMP算法 参考文档： https://www.cnblogs.com/zzuuoo666/p/9028287.html package im.bool.a15_ten_algrithm; import java.util.Arrays; /** * @author : 不二 * @date : 2021/5/23-下午2:39 * @desc : KMP算法演示 * 看了一下午还是没看懂。。。。。。。。。。 **/ public class a15_04_KMPDemo { public static void main(String[] args) { /*String sourceStr = \"----01\"; String targetStr = \"01\";*/ String sourceStr = \"BBC ABCDAB ABCDABCDABDE\"; String targetStr = \"ABCDABD\"; // 先 用暴力解法进行测试 int targetIndex = violenceMatch(sourceStr, targetStr); System.out.println(\"暴力匹配到结果为:\" + targetIndex); int targetIndex01 = violenceMatch_v1(sourceStr, targetStr); System.out.println(\"暴力匹配到结果为:\" + targetIndex01); int[] aas = kmpNext(\"ABCDABD\"); System.out.println(\"部分匹配值为：\" + Arrays.toString(aas)); int targetIndex02 = kmpAlgrithm(sourceStr, targetStr); System.out.println(\"kmp算法匹配到结果为:\" + targetIndex02); } /** * 用kmp算法匹配字符串 * @param sourceStr * @param targetStr 目标字符串 * @return */ private static int kmpAlgrithm(String sourceStr, String targetStr) { // 先计算出部分匹配值方便后续使用 int[] next = kmpNext(targetStr); for (int i = 0, j = 0; i 0 && sourceStr.charAt(i) != targetStr.charAt(j)) { j = next[j - 1]; } if (sourceStr.charAt(i) == targetStr.charAt(j)) { j++; } /*else { // 这里是暴力匹配 // i = i - j; // kmp算法中：这里不是从开始点往后推一位，而是通过部分配置值进行跳跃回溯 j = 0; }*/ if (j == targetStr.length()) { System.out.println(\"找到结果\"); return i - j + 1; } } return -1; } /** * 获取匹配串的加速匹配的信息(部分匹配值，也就是前缀和后缀重复的个数) * @param targetStr: 目标字符串 * @return */ private static int[] kmpNext(String targetStr){ // 创建一个数组，保存 部分匹配值， 也就是加速匹配值的信息 int[] next = new int[targetStr.length()]; // 如果字符串是单个字符串，没有前缀和后缀，所以是0 next[0] = 0; // j表示匹配值的个数 for (int i = 1, matched = 0; i 0 && targetStr.charAt(i) != targetStr.charAt(matched)) { matched = next[matched - 1]; } // 相等的时候有如下规律 if (targetStr.charAt(i) == targetStr.charAt(matched)) { matched++; } next[i] = matched; } return next; } /** * 暴力匹配字符串--这个是用while循环实现教程中方法 * @param sourceStr * @param targetStr * @return */ private static int violenceMatch_v1(String sourceStr, String targetStr) { char[] sourceChars = sourceStr.toCharArray(); char[] targetChars = targetStr.toCharArray(); int i = 0; int j = 0; while (i 1.5. 5, 贪心算法 1.6. 6, 普里姆算法 1.7. 7, 克鲁斯卡尔算法 1.8. 8, Dijkstra算法 1.9. 9, Floyd算法 1.10. 10, 骑士周游(马踏棋盘)算法 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 不二 链接: https://ivanl001.github.io/01-algthrim/02-hanshunping/02-算法03-程序员常用的十种算法.html 来源: 不二技术博客 本文原创发布于「不二技术博客」,转载请注明出处,谢谢合作! © 不二 all right reserved，powered by Gitbook文件修订时间: 2021-05-23 13:14:19 "}}