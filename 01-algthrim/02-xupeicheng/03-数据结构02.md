[toc]

<extoc></extoc>



#### 1.2.4, 树结构

```shell
# 为什么需要树结构?
# 1, 数组查询速度快，但是插入速度慢，因为插入的时候实际是进行数组的复制
# 2, 链表插入速度快，但是查询的时候需要重头开始遍历，速度又会有一定限制

# 如果使用树结构，可以实现查询速度较快，插入速度也较快
```



满二叉树：所有的叶子结点都是在最后一级

* 遍历的时候看主节点，先遍历主节点就是前序遍历，中间遍历主节点，是中序遍历，最后遍历主节点，是后序遍历

* ==前序遍历==: 先遍历主节点，然后遍历左节点，最后遍历右节点
* ==中序遍历==: 先遍历左节点， 然后遍历主节点，最后遍历右节点
* ==后序遍历==: 先遍历左节点，然后遍历右节点，最后遍历主节点



##### 二叉树的遍历/查找/删除

```java
package im.bool.a09_tree;

/**
 * @author : 不二
 * @date : 2021/5/8-下午8:25
 * @desc : 二叉树代码重写
 * 包括二叉树前中后三种遍历方式
 * 以及二叉树的前中后三种查找方式
 * 以及二叉树的元素删除
 **/
public class a09_01_BinaryTreeDemo_v1 {
    public static void main(String[] args) {

        // 首先构造一个数类并添加节点元素
        StudentBinaryTree binaryTree = new StudentBinaryTree();
        StudentNode heroNode00 = new StudentNode(0, "1");
        StudentNode heroNode01 = new StudentNode(1, "1");
        StudentNode heroNode02 = new StudentNode(2, "2");
        StudentNode heroNode03 = new StudentNode(3, "3");
        StudentNode heroNode04 = new StudentNode(4, "4");
        StudentNode heroNode05 = new StudentNode(5, "5");
        StudentNode heroNode06 = new StudentNode(6, "6");
        StudentNode heroNode07 = new StudentNode(7, "7");
        StudentNode heroNode08 = new StudentNode(8, "8");
        StudentNode heroNode09 = new StudentNode(9, "9");
        StudentNode heroNode10 = new StudentNode(10, "10");
        StudentNode heroNode11 = new StudentNode(11, "11");
        StudentNode heroNode12 = new StudentNode(12, "12");
        StudentNode heroNode13 = new StudentNode(13, "13");
        StudentNode heroNode14 = new StudentNode(14, "14");

        /*
                       0
               1                 2
           3       4        5          6
         7  8    9  10    11  12     13  14
         */


        // 设置第一行
        binaryTree.setRootStudent(heroNode00);

        heroNode00.setLeft(heroNode01);
        heroNode00.setRight(heroNode02);

        heroNode01.setLeft(heroNode03);
        heroNode01.setRight(heroNode04);
        heroNode02.setLeft(heroNode05);
        heroNode02.setRight(heroNode06);

        heroNode03.setLeft(heroNode07);
        heroNode03.setRight(heroNode08);
        heroNode04.setLeft(heroNode09);
        heroNode04.setRight(heroNode10);
        heroNode05.setLeft(heroNode11);
        heroNode05.setRight(heroNode12);
        heroNode06.setLeft(heroNode13);
        heroNode06.setRight(heroNode14);

        System.out.println("前序遍历：");
        binaryTree.preOrder();// 1 2 3 5 4

        System.out.println("中序遍历：");
        binaryTree.infixOrder();// 2 1 5 3 4

        System.out.println("后序遍历：");
        binaryTree.suffixOrder();// 2 5 4 3 1

        /*System.out.println("前序查找：");
        StudentNode studentNode = binaryTree.preOrderSearch(5);
        System.out.println(studentNode);

        System.out.println("中序查找：");
        StudentNode studentNode1 = binaryTree.infixOrderSearch(5);
        System.out.println(studentNode1);

        System.out.println("后序查找：");
        StudentNode studentNode2 = binaryTree.suffixOrderSearch(5);
        System.out.println(studentNode2);

        // 此处规定：如果删除的是叶子节点，直接删除即可
        //         如果删除的是非叶子节点，把该非叶子节点下所有的节点都一并删除掉
        System.out.println("删除节点：");
        binaryTree.deleteNode(5);
        System.out.println("Ivanl001");*/
    }
}

class StudentBinaryTree {

    StudentNode rootStudent;

    public StudentNode getRootStudent() {
        return rootStudent;
    }

    public void setRootStudent(StudentNode rootStudent) {
        this.rootStudent = rootStudent;
    }

    // 前序查找
    public StudentNode preOrderSearch(int id) {
        return this.rootStudent.preOrderSearch(id);
    }
    // 中序查找
    public StudentNode infixOrderSearch(int id) {
        return this.rootStudent.infixSearch(id);
    }
    // 后序查找
    public StudentNode suffixOrderSearch(int id) {
        return this.rootStudent.suffixOrderSearch(id);
    }


    // 前序遍历(先遍历主节点，然后遍历左节点，最后遍历右节点)
    public void preOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.preOrder();
        }
    }

    // 中序遍历(先遍历左节点， 然后遍历主节点，最后遍历右节点)
    public void infixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.infixOrder();
        }
    }

    // 后序遍历(先遍历左节点，然后遍历右节点，最后遍历主节点)
    public void suffixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.suffixOrder();
        }
    }

    public void deleteNode(int i) {

        if (this.rootStudent.getId() == i) {
            System.out.println("删除的是最顶层根节点，无法删除!");
        } else {
            this.rootStudent.deleteNode(i);
        }
    }
}


// 这里是个学生类的二叉树子节点
class StudentNode {

    private int id;
    private String name;
    private StudentNode left;
    private StudentNode right;

    public StudentNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    //删除
    public void deleteNode_v1(int no) {
        //这里和遍历或者查找不一样哈， 因为如果是遍历，是不会返回的
        //这里就只能默认只有一个
        if (this.left != null && this.left.id == no) {
            this.left = null;
            return;
        }
        if (this.right != null && this.right.id == no) {
            this.right = null;
            return;
        }
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }

    public void deleteNode(int id) {

        if (this.left != null) {
            if (this.getLeft().getId() == id) {
                this.setLeft(null);
                return;
            }
            this.left.deleteNode(id);
        }

        if (this.right != null) {
            if (this.getRight().getId() == id) {
                this.setRight(null);
                return;
            }
            this.right.deleteNode(id);
        }

        /*if (this.getLeft().getId() == id) {
            this.setLeft(null);
            return;
        }
        if (this.getRight().getId() == id) {
            this.setRight(null);
            return;
        }*/


    }


    public StudentNode preOrderSearch(int id) {
        // 1, 先找根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 2, 然后找左节点
        StudentNode studentNode = null;
        if (this.getLeft() != null) {
            studentNode = this.getLeft().preOrderSearch(id);
        }
        // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (studentNode != null) {
            return studentNode;
        }

        // 3, 最后找右节点
        // 如果studentNode 为null，说明还未找到
        if (this.getRight() != null) {
            studentNode = this.getRight().preOrderSearch(id);
        }
        // 这里为null说明为找到
        return studentNode;
    }

    public StudentNode infixSearch(int id) {

        // 1，先找左节点
        StudentNode studentNode = null;
        if (this.getLeft() != null) {
            studentNode = this.getLeft().infixSearch(id);
        }

        // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        // 左节点找到直接返回左节点
        if (studentNode != null) {
            return studentNode;
        }

        // 2，然后找根节点
        // 左节点没找到对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 3，最后找右节点
        // 如果根节点也没找到，找右节点
        // 如果studentNode 为null，说明还未找到
        if (this.getRight() != null) {
            studentNode = this.getRight().infixSearch(id);
        }
        // 这里为null说明为找到
        return studentNode;
    }

    public StudentNode suffixOrderSearch(int id) {

        // 1，先找左节点
        // 左节点找到直接返回左节点
        StudentNode studentNode = null;
        if (this.getLeft() != null) {
            studentNode = this.getLeft().suffixOrderSearch(id);
        }
        // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (studentNode != null) {
            return studentNode;
        }

        // 2，然后找右节点
        // 如果左节点没找到，找右节点
        // 如果studentNode 为null，说明还未找到
        if (this.getRight() != null) {
            studentNode = this.getRight().suffixOrderSearch(id);
        }

        // 如果右侧ok了直接返回就行了
        if (studentNode != null) {
            return studentNode;
        }

        // 3，最后找根节点
        // 如果左右都没找到， 再对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 这里为null说明为找到
        return studentNode;
    }

    public void preOrder(){
        // 先打印出当前
        System.out.println(this);

        if (this.left != null) {
            this.left.preOrder();
        }

        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    public void suffixOrder() {
        if (this.left != null) {
            this.left.suffixOrder();
        }
        if (this.right != null) {
            this.right.suffixOrder();
        }
        System.out.println(this);
    }

    @Override
    public String toString() {
        return "StudentNode{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
    public StudentNode getLeft() {
        return left;
    }
    public void setLeft(StudentNode left) {
        this.left = left;
    }
    public StudentNode getRight() {
        return right;
    }
    public void setRight(StudentNode right) {
        this.right = right;
    }

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}

```



##### 顺序存储二叉树

* 就是通过数组存储二叉树
* <img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210509134323445.png" alt="image-20210509134323445" style="zoom:50%;" />

```java
package im.bool.a09_tree;

/**
 * @author : 不二
 * @date : 2021/5/9-下午1:47
 * @desc : 数组存储二叉树并实现从数组中按照二叉树的前序中序后序方式读取数据代码重新
 **/
public class a09_02_BinaryTreeToArrDemo_v1 {

    public static void main(String[] args) {

        //int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        int[] arr = {1, 3, 6, 8, 10, 14};
        ArrBinaryTreeV1 arrBinaryTree = new ArrBinaryTreeV1(arr);

        System.out.println("数组左序遍历：");
        arrBinaryTree.preOrder();

        System.out.println("数组中序遍历：");
        arrBinaryTree.infixOrder();

        System.out.println("数组后序遍历：");
        arrBinaryTree.suffixOrder();
    }
}

class ArrBinaryTreeV1 {
    private final int[] arr;
    public ArrBinaryTreeV1(int[] arr) {
        this.arr = arr;
    }

    public void preOrder() {
        preOrder01(0);
    }

    // 前序遍历
    public void preOrder01(int n) {

        if (arr != null && arr.length == 0) {
            System.out.println("当前数组为空");
        }

        System.out.println(arr[n]);

        int left = 2 * n + 1;
        int right = 2 * n + 2;
        if (left < arr.length) {
            preOrder01(left);
        }
        if (right < arr.length) {
            preOrder01(right);
        }
    }

    public void infixOrder() {
        infixOrder01(0);
    }

    private void infixOrder01(int n) {
        if (arr.length == 0) {
            System.out.println("无元素");
        }
        int left = 2 * n + 1;
        int right = 2 * n + 2;
        if (left < arr.length) {
            infixOrder01(left);
        }
        System.out.println(arr[n]);
        if (right < arr.length) {
            infixOrder01(right);
        }
    }

    public void suffixOrder() {
        suffixOrder01(0);
    }

    private void suffixOrder01(int n) {
        if (arr.length == 0) {
            System.out.println("无元素");
        }
        int left = 2 * n + 1;
        int right = 2 * n + 2;
        if (left < arr.length) {
            suffixOrder01(left);
        }
        if (right < arr.length) {
            suffixOrder01(right);
        }
        System.out.println(arr[n]);
    }
}
```

##### 线索化二叉树

* n个节点的二叉树链表中含有：==n+1(计算公式:2n-(n-1), 其中2n为n个节点的所有指针数，n-1为n个节点彼此连接的指针数。所有指针减去连接的指针，剩下的就是空指针)==个空指针域。
* 利用二叉链表中的空指针域，存放指向节点在==某种遍历次序==下的前驱和后继节点的指针，这种附加的指针叫做线索
* 加上这种线索的二叉树链表又被称为线索链表，相应的二叉树被称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树又分为：前序线索二叉树，中序线索二叉树，后续线索二叉树。
* 一个节点的前一个节点，称为前驱节点
* 一个节点的后一个节点，称为后继节点



线索化以及线索化后的二叉树的遍历

* 其中二叉树的遍历超级巧妙。需要仔细品味
* 画图更容易理解一些

```java
package im.bool.a09_tree;

/**
 * @author : 不二
 * @date : 2021/5/8-下午8:25
 * @desc : 线索化二叉树代码重写(之前教程看过，不过前面那份代码没写完， 就删除了，这里重新写一份)
 *         我们这里通过中序遍历进行线索化二叉树，也就是先线索化左子树，然后线索化当前节点，最后线索化右子树
 **/
public class a09_03_ThreadBinaryTreeDemo {

    public static void main(String[] args) {

        // 这个是简单的二叉树模型
        /*ThreadStudentBinaryTree binaryTree = new ThreadStudentBinaryTree();
        ThreadStudentNode heroNode01 = new ThreadStudentNode(1, "1");
        ThreadStudentNode heroNode03 = new ThreadStudentNode(3, "3");
        ThreadStudentNode heroNode06 = new ThreadStudentNode(6, "6");
        ThreadStudentNode heroNode08 = new ThreadStudentNode(8, "8");
        ThreadStudentNode heroNode10= new ThreadStudentNode(10, "10");
        ThreadStudentNode heroNode14 = new ThreadStudentNode(14, "14");

        heroNode01.setLeft(heroNode03);
        heroNode01.setRight(heroNode06);

        heroNode03.setLeft(heroNode08);
        heroNode03.setRight(heroNode10);

        heroNode06.setLeft(heroNode14);

        binaryTree.setRootStudent(heroNode01);*/


        // 用复杂一点的二叉树看一下效果
        // 首先构造一个数类并添加节点元素
        ThreadStudentBinaryTree binaryTree = new ThreadStudentBinaryTree();
        ThreadStudentNode heroNode00 = new ThreadStudentNode(0, "1");
        ThreadStudentNode heroNode01 = new ThreadStudentNode(1, "1");
        ThreadStudentNode heroNode02 = new ThreadStudentNode(2, "2");
        ThreadStudentNode heroNode03 = new ThreadStudentNode(3, "3");
        ThreadStudentNode heroNode04 = new ThreadStudentNode(4, "4");
        ThreadStudentNode heroNode05 = new ThreadStudentNode(5, "5");
        ThreadStudentNode heroNode06 = new ThreadStudentNode(6, "6");
        ThreadStudentNode heroNode07 = new ThreadStudentNode(7, "7");
        ThreadStudentNode heroNode08 = new ThreadStudentNode(8, "8");
        ThreadStudentNode heroNode09 = new ThreadStudentNode(9, "9");
        ThreadStudentNode heroNode10 = new ThreadStudentNode(10, "10");
        ThreadStudentNode heroNode11 = new ThreadStudentNode(11, "11");
        ThreadStudentNode heroNode12 = new ThreadStudentNode(12, "12");
        ThreadStudentNode heroNode13 = new ThreadStudentNode(13, "13");
        ThreadStudentNode heroNode14 = new ThreadStudentNode(14, "14");
        /*
                       0
               1                 2
           3       4        5          6
         7  8    9  10    11  12     13  14
         */
        // 设置第一行
        binaryTree.setRootStudent(heroNode00);

        heroNode00.setLeft(heroNode01);
        heroNode00.setRight(heroNode02);

        heroNode01.setLeft(heroNode03);
        heroNode01.setRight(heroNode04);
        heroNode02.setLeft(heroNode05);
        heroNode02.setRight(heroNode06);

        heroNode03.setLeft(heroNode07);
        heroNode03.setRight(heroNode08);
        heroNode04.setLeft(heroNode09);
        heroNode04.setRight(heroNode10);
        heroNode05.setLeft(heroNode11);
        heroNode05.setRight(heroNode12);
        heroNode06.setLeft(heroNode13);
        heroNode06.setRight(heroNode14);

        // 中序先打印一把
        System.out.println("中序打印--");
        binaryTree.infixOrder();


        // 这里调用重载的方法
        binaryTree.threadNodes();
        /*ThreadStudentNode studentNode = heroNode10;
        System.out.println("10号节点的左节点:" + studentNode.getLeft());
        System.out.println("10号节点的右节点:" + studentNode.getRight());*/

        // 使用线索化遍历
        System.out.println("使用线索化方式进行遍历--");
        binaryTree.threadedList();

    }
}

class ThreadStudentBinaryTree {

    ThreadStudentNode rootStudent;

    // 为了实现线索化，需要锁定前节点
    ThreadStudentNode preStudent;

    public ThreadStudentNode getRootStudent() {
        return rootStudent;
    }
    public void setRootStudent(ThreadStudentNode rootStudent) {
        this.rootStudent = rootStudent;
    }

    // 这里直接方法重载即可
    public void threadNodes() {
        threadNodes(rootStudent);
    }

    public void threadedList() {
        ThreadStudentNode node = rootStudent;

        while (node != null) {
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            // 这里暂时不是特别明白。
            System.out.println(node);
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
            System.out.println("------------又一轮---------");
            node = node.getRight();
        }
    }

    // 二叉树线索化的方法
    // 这里再构造方法里面直接线索化即可
    public void threadNodes(ThreadStudentNode studentNode) {

        // System.out.println(studentNode);

        if (studentNode == null) {
            // System.out.println("节点为null，返回");
            // 当前节点都为null了，那肯定没有左右节点了， 直接返回即可了
            return;
        }

        // 1, 先线索化左子树(调用当前方法即可)
        threadNodes(studentNode.getLeft());

        // 2, 然后线索化当前节点(真正线索化的内容)
        if (studentNode.getLeft() == null) {
            studentNode.setLeft(preStudent);
            studentNode.setLeftType(1);
        }

        // 这里还需要添加个判断：preStudent != null
        // 注意：这里要判断的是前一个的right是null，别判断成当前节点了，吃亏了
        if (preStudent != null && preStudent.getRight() == null) {
            // 这个相当于是这次处理上个节点的right引用。下次再设置本个节点的right引用。
            // 比较巧妙
            preStudent.setRight(studentNode);
            preStudent.setRightType(1);
        }

        preStudent = studentNode;

        // 3, 最后线索化右子树(调用当前方法即可)
        threadNodes(studentNode.getRight());
    }



    // 前序查找
    public ThreadStudentNode preOrderSearch(int id) {
        return this.rootStudent.preOrderSearch(id);
    }
    // 中序查找
    public ThreadStudentNode infixOrderSearch(int id) {
        return this.rootStudent.infixSearch(id);
    }
    // 后序查找
    public ThreadStudentNode suffixOrderSearch(int id) {
        return this.rootStudent.suffixOrderSearch(id);
    }


    // 前序遍历(先遍历主节点，然后遍历左节点，最后遍历右节点)
    public void preOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.preOrder();
        }
    }

    // 中序遍历(先遍历左节点， 然后遍历主节点，最后遍历右节点)
    public void infixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.infixOrder();
        }
    }

    // 后序遍历(先遍历左节点，然后遍历右节点，最后遍历主节点)
    public void suffixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.suffixOrder();
        }
    }

    public void deleteNode(int i) {

        if (this.rootStudent.getId() == i) {
            System.out.println("删除的是最顶层根节点，无法删除!");
        } else {
            this.rootStudent.deleteNode(i);
        }
    }
}


// 这里是个学生类的二叉树子节点
class ThreadStudentNode {

    private int id;
    private String name;
    private ThreadStudentNode left;
    private ThreadStudentNode right;

    // 这里需要设置两个成员变量， 来确定左右指针的类型是默认的子树，还是线索化设置的引用
    // 这里如果默认是0就是默认的子树， 如果是1则表示是线索化设置的引用
    private int leftType;
    private int rightType;


    public ThreadStudentNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    //删除
    public void deleteNode_v1(int no) {
        //这里和遍历或者查找不一样哈， 因为如果是遍历，是不会返回的
        //这里就只能默认只有一个
        if (this.left != null && this.left.id == no) {
            this.left = null;
            return;
        }
        if (this.right != null && this.right.id == no) {
            this.right = null;
            return;
        }
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
    public void deleteNode(int id) {
        if (this.left != null) {
            if (this.getLeft().getId() == id) {
                this.setLeft(null);
                return;
            }
            this.left.deleteNode(id);
        }

        if (this.right != null) {
            if (this.getRight().getId() == id) {
                this.setRight(null);
                return;
            }
            this.right.deleteNode(id);
        }
    }

    public ThreadStudentNode preOrderSearch(int id) {
        // 1, 先找根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 2, 然后找左节点
        ThreadStudentNode ThreadStudentNode = null;
        if (this.getLeft() != null) {
            ThreadStudentNode = this.getLeft().preOrderSearch(id);
        }
        // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 3, 最后找右节点
        // 如果ThreadStudentNode 为null，说明还未找到
        if (this.getRight() != null) {
            ThreadStudentNode = this.getRight().preOrderSearch(id);
        }
        // 这里为null说明为找到
        return ThreadStudentNode;
    }

    public ThreadStudentNode infixSearch(int id) {

        // 1，先找左节点
        ThreadStudentNode ThreadStudentNode = null;
        if (this.getLeft() != null) {
            ThreadStudentNode = this.getLeft().infixSearch(id);
        }

        // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        // 左节点找到直接返回左节点
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 2，然后找根节点
        // 左节点没找到对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 3，最后找右节点
        // 如果根节点也没找到，找右节点
        // 如果ThreadStudentNode 为null，说明还未找到
        if (this.getRight() != null) {
            ThreadStudentNode = this.getRight().infixSearch(id);
        }
        // 这里为null说明为找到
        return ThreadStudentNode;
    }

    public ThreadStudentNode suffixOrderSearch(int id) {

        // 1，先找左节点
        // 左节点找到直接返回左节点
        ThreadStudentNode ThreadStudentNode = null;
        if (this.getLeft() != null) {
            ThreadStudentNode = this.getLeft().suffixOrderSearch(id);
        }
        // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 2，然后找右节点
        // 如果左节点没找到，找右节点
        // 如果ThreadStudentNode 为null，说明还未找到
        if (this.getRight() != null) {
            ThreadStudentNode = this.getRight().suffixOrderSearch(id);
        }

        // 如果右侧ok了直接返回就行了
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 3，最后找根节点
        // 如果左右都没找到， 再对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 这里为null说明为找到
        return ThreadStudentNode;
    }

    public void preOrder(){
        // 先打印出当前
        System.out.println(this);

        if (this.left != null) {
            this.left.preOrder();
        }

        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    public void suffixOrder() {
        if (this.left != null) {
            this.left.suffixOrder();
        }
        if (this.right != null) {
            this.right.suffixOrder();
        }
        System.out.println(this);
    }

    @Override
    public String toString() {
        return "ThreadStudentNode{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
    public ThreadStudentNode getLeft() {
        return left;
    }
    public void setLeft(ThreadStudentNode left) {
        this.left = left;
    }
    public ThreadStudentNode getRight() {
        return right;
    }
    public void setRight(ThreadStudentNode right) {
        this.right = right;
    }

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getLeftType() {
        return leftType;
    }
    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }
    public int getRightType() {
        return rightType;
    }
    public void setRightType(int rightType) {
        this.rightType = rightType;
    }
}
```



#### 1.2.5, 树的实际应用

##### 堆排序

* 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它最好，最坏以及平均复杂度均为O(nlogn)，它是不稳定的排序
* 堆是具有以下性质的完全二叉树：
* 大顶堆：每个节点的值大于或者等于其左右孩子节点的值(变成顺序存储二叉树的时候，数组是从大到小的)
* <img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210509193615819.png" alt="image-20210509193615819" style="zoom:50%;" />
* 小顶堆：每个节点的值都小于或等于其左右孩子节点的值(变成顺序存储二叉树的时候，数组是从小到大的)
* <img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210509193701930.png" alt="image-20210509193701930" style="zoom:50%;" />

```java
```



##### Huffman Tree(赫夫曼树)

* 给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度wpl:weighted path length达到最小，则称为最优二叉树，即是Huffman Tree
* 赫夫曼树是带权路径最短的树，权值较大的节点离根较近

