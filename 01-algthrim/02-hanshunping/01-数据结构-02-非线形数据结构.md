[toc]

<extoc></extoc>



## 数据结构

> 数据结构是算法的基础
>
> 数据结构分为线性结构和非线性结构



### 2, 非线性结构

> 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构



数组每次插入都需要复制当前数据到一个新的数据才能有类似扩容的功能。List其实是一种优化的数组，会尽量批量扩容，不会每次插入扩容，底层使用的还是数组。这种因素导致数组在插入的时候速度慢。

然后链表的话插入的时候速度就很快了，但是查找的时候，如果链表数据很多，就需要从头查找到尾部，其实相对而言查找速度就比较慢。

这就是学习树结构的原因。



![image-20210424120456403](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210424120456403.png)



![image-20210424120519921](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210424120519921.png)







#### 2.1, 二维数组

> ==一维数组为线型结构，但是二维数组则为非线形结构==

##### 稀疏数组(sparseArray)

> 稀疏数组其实是一个二维数组，这里放在线性结构的数组里面并不合适。所以放入非线性结构的二维数组中记录
>
> 稀疏数组：数组中有多少个非0数字， 其转化成稀疏数组后， 对应的行数为数字个数+1，其列数固定为3列；
>
> 其中第0行：记录数组的总总行数列数以及对应的非0数字个数
>
> 第i行分别记录第i个不为的数字的行数，列数以及具体值



![image-20210424120310862](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210424120310862.png)

```java
package im.bool;

/**
 * #Author : ivanl001
 * #Date   : 2019/11/2 14:12
 * #Desc   : 稀疏数组-棋盘的应用
 **/
public class a01_sparseArray {

    public static void main(String[] args) {

        //棋盘 11*11
        //0表示没有棋子，1表示黑子， 2表示蓝子
        int[][] chessArr = new int[11][11];
        chessArr[1][2] = 1;
        chessArr[2][3] = 2;
        chessArr[2][4] = 2;
        chessArr[3][4] = 2;

        System.out.println("原始棋盘二维数组是：------------------------------------");
        printArr(chessArr);
        /*for (int[] row : chessArr) {
            for (int num : row) {
                System.out.printf(num + "\t");
            }
            System.out.println("\n");
        }*/


        System.out.println("开始转换成稀疏数组：-------------------------------------");
        //1，先遍历二维数组，得到非0数据个数
        int sum = 0;
        for (int[] ints : chessArr) {
            for (int anInt : ints) {
                if (anInt != 0) {
                    sum++;
                }
            }
        }
        System.out.println("遍历之后获取到非零数据个数：" + sum);


         //2, 创建稀疏数组
        int[][] sparseArr = new int[1 + sum][3];

        //3, 给稀疏数组赋值
        //-------第一行是整体描述---------
        //说明原先数组有11行
        sparseArr[0][0] = 11;
        //说明原先数组有11列
        sparseArr[0][1] = 11;
        //说明原先数组有sum个不为零到数字
        sparseArr[0][2] = sum;
        //-------其余行是非零描述--------
        int count = 0;
        for (int i = 0; i < chessArr.length; i++) {
            for (int j = 0; j < chessArr[i].length; j++) {
                if (chessArr[i][j] != 0) {
                    count ++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr[i][j];

                }
            }
        }

        //打印稀疏数组
        System.out.println("稀疏数组是：");
        printArr(sparseArr);


        System.out.println("把稀疏数组转换回原始二维数组:----------------------------");
        int rowNum = sparseArr[0][0];
        int columnNum = sparseArr[0][1];
        int[][] theOriginalArr = new int[rowNum][columnNum];
        for (int i = 1; i < sparseArr.length; i++) {
            theOriginalArr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        System.out.println("恢复后的二维数组是：---------------------------");
        printArr(theOriginalArr);
    }

    private static void printArr(int[][] arr){
        for (int[] row : arr) {
            for (int num : row) {
                System.out.printf(num + "\t");
            }
            System.out.println("\n");
        }
    }

}

```



#### 2.2, 多维数组

```shell
# 跳过不表
```



#### 2.3, 树结构

```shell
# 为什么需要树结构?
# 1, 数组查询速度快，但是插入速度慢，因为插入的时候实际是进行数组的复制
# 2, 链表插入速度快，但是查询的时候需要重头开始遍历，速度又会有一定限制

# 如果使用树结构，可以实现查询速度较快，插入速度也较快
```



满二叉树：所有的叶子结点都是在最后一级

* 遍历的时候看主节点，先遍历主节点就是前序遍历，中间遍历主节点，是中序遍历，最后遍历主节点，是后序遍历

* ==前序遍历==: 先遍历主节点，然后遍历左节点，最后遍历右节点
* ==中序遍历==: 先遍历左节点， 然后遍历主节点，最后遍历右节点
* ==后序遍历==: 先遍历左节点，然后遍历右节点，最后遍历主节点



##### 1, 二叉树的遍历/查找/删除

```java
package im.bool.a09_tree;

/**
 * @author : 不二
 * @date : 2021/5/8-下午8:25
 * @desc : 二叉树代码重写
 * 包括二叉树前中后三种遍历方式
 * 以及二叉树的前中后三种查找方式
 * 以及二叉树的元素删除
 **/
public class a09_01_BinaryTreeDemo_v1 {
    public static void main(String[] args) {

        // 首先构造一个数类并添加节点元素
        StudentBinaryTree binaryTree = new StudentBinaryTree();
        StudentNode heroNode00 = new StudentNode(0, "1");
        StudentNode heroNode01 = new StudentNode(1, "1");
        StudentNode heroNode02 = new StudentNode(2, "2");
        StudentNode heroNode03 = new StudentNode(3, "3");
        StudentNode heroNode04 = new StudentNode(4, "4");
        StudentNode heroNode05 = new StudentNode(5, "5");
        StudentNode heroNode06 = new StudentNode(6, "6");
        StudentNode heroNode07 = new StudentNode(7, "7");
        StudentNode heroNode08 = new StudentNode(8, "8");
        StudentNode heroNode09 = new StudentNode(9, "9");
        StudentNode heroNode10 = new StudentNode(10, "10");
        StudentNode heroNode11 = new StudentNode(11, "11");
        StudentNode heroNode12 = new StudentNode(12, "12");
        StudentNode heroNode13 = new StudentNode(13, "13");
        StudentNode heroNode14 = new StudentNode(14, "14");

        /*
                       0
               1                 2
           3       4        5          6
         7  8    9  10    11  12     13  14
         */


        // 设置第一行
        binaryTree.setRootStudent(heroNode00);

        heroNode00.setLeft(heroNode01);
        heroNode00.setRight(heroNode02);

        heroNode01.setLeft(heroNode03);
        heroNode01.setRight(heroNode04);
        heroNode02.setLeft(heroNode05);
        heroNode02.setRight(heroNode06);

        heroNode03.setLeft(heroNode07);
        heroNode03.setRight(heroNode08);
        heroNode04.setLeft(heroNode09);
        heroNode04.setRight(heroNode10);
        heroNode05.setLeft(heroNode11);
        heroNode05.setRight(heroNode12);
        heroNode06.setLeft(heroNode13);
        heroNode06.setRight(heroNode14);

        System.out.println("前序遍历：");
        binaryTree.preOrder();// 1 2 3 5 4

        System.out.println("中序遍历：");
        binaryTree.infixOrder();// 2 1 5 3 4

        System.out.println("后序遍历：");
        binaryTree.suffixOrder();// 2 5 4 3 1

        /*System.out.println("前序查找：");
        StudentNode studentNode = binaryTree.preOrderSearch(5);
        System.out.println(studentNode);

        System.out.println("中序查找：");
        StudentNode studentNode1 = binaryTree.infixOrderSearch(5);
        System.out.println(studentNode1);

        System.out.println("后序查找：");
        StudentNode studentNode2 = binaryTree.suffixOrderSearch(5);
        System.out.println(studentNode2);

        // 此处规定：如果删除的是叶子节点，直接删除即可
        //         如果删除的是非叶子节点，把该非叶子节点下所有的节点都一并删除掉
        System.out.println("删除节点：");
        binaryTree.deleteNode(5);
        System.out.println("Ivanl001");*/
    }
}

class StudentBinaryTree {

    StudentNode rootStudent;

    public StudentNode getRootStudent() {
        return rootStudent;
    }

    public void setRootStudent(StudentNode rootStudent) {
        this.rootStudent = rootStudent;
    }

    // 前序查找
    public StudentNode preOrderSearch(int id) {
        return this.rootStudent.preOrderSearch(id);
    }
    // 中序查找
    public StudentNode infixOrderSearch(int id) {
        return this.rootStudent.infixSearch(id);
    }
    // 后序查找
    public StudentNode suffixOrderSearch(int id) {
        return this.rootStudent.suffixOrderSearch(id);
    }


    // 前序遍历(先遍历主节点，然后遍历左节点，最后遍历右节点)
    public void preOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.preOrder();
        }
    }

    // 中序遍历(先遍历左节点， 然后遍历主节点，最后遍历右节点)
    public void infixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.infixOrder();
        }
    }

    // 后序遍历(先遍历左节点，然后遍历右节点，最后遍历主节点)
    public void suffixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.suffixOrder();
        }
    }

    public void deleteNode(int i) {

        if (this.rootStudent.getId() == i) {
            System.out.println("删除的是最顶层根节点，无法删除!");
        } else {
            this.rootStudent.deleteNode(i);
        }
    }
}


// 这里是个学生类的二叉树子节点
class StudentNode {

    private int id;
    private String name;
    private StudentNode left;
    private StudentNode right;

    public StudentNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    //删除
    public void deleteNode_v1(int no) {
        //这里和遍历或者查找不一样哈， 因为如果是遍历，是不会返回的
        //这里就只能默认只有一个
        if (this.left != null && this.left.id == no) {
            this.left = null;
            return;
        }
        if (this.right != null && this.right.id == no) {
            this.right = null;
            return;
        }
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }

    public void deleteNode(int id) {

        if (this.left != null) {
            if (this.getLeft().getId() == id) {
                this.setLeft(null);
                return;
            }
            this.left.deleteNode(id);
        }

        if (this.right != null) {
            if (this.getRight().getId() == id) {
                this.setRight(null);
                return;
            }
            this.right.deleteNode(id);
        }

        /*if (this.getLeft().getId() == id) {
            this.setLeft(null);
            return;
        }
        if (this.getRight().getId() == id) {
            this.setRight(null);
            return;
        }*/


    }


    public StudentNode preOrderSearch(int id) {
        // 1, 先找根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 2, 然后找左节点
        StudentNode studentNode = null;
        if (this.getLeft() != null) {
            studentNode = this.getLeft().preOrderSearch(id);
        }
        // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (studentNode != null) {
            return studentNode;
        }

        // 3, 最后找右节点
        // 如果studentNode 为null，说明还未找到
        if (this.getRight() != null) {
            studentNode = this.getRight().preOrderSearch(id);
        }
        // 这里为null说明为找到
        return studentNode;
    }

    public StudentNode infixSearch(int id) {

        // 1，先找左节点
        StudentNode studentNode = null;
        if (this.getLeft() != null) {
            studentNode = this.getLeft().infixSearch(id);
        }

        // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        // 左节点找到直接返回左节点
        if (studentNode != null) {
            return studentNode;
        }

        // 2，然后找根节点
        // 左节点没找到对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 3，最后找右节点
        // 如果根节点也没找到，找右节点
        // 如果studentNode 为null，说明还未找到
        if (this.getRight() != null) {
            studentNode = this.getRight().infixSearch(id);
        }
        // 这里为null说明为找到
        return studentNode;
    }

    public StudentNode suffixOrderSearch(int id) {

        // 1，先找左节点
        // 左节点找到直接返回左节点
        StudentNode studentNode = null;
        if (this.getLeft() != null) {
            studentNode = this.getLeft().suffixOrderSearch(id);
        }
        // 这里使用studentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (studentNode != null) {
            return studentNode;
        }

        // 2，然后找右节点
        // 如果左节点没找到，找右节点
        // 如果studentNode 为null，说明还未找到
        if (this.getRight() != null) {
            studentNode = this.getRight().suffixOrderSearch(id);
        }

        // 如果右侧ok了直接返回就行了
        if (studentNode != null) {
            return studentNode;
        }

        // 3，最后找根节点
        // 如果左右都没找到， 再对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 这里为null说明为找到
        return studentNode;
    }

    public void preOrder(){
        // 先打印出当前
        System.out.println(this);

        if (this.left != null) {
            this.left.preOrder();
        }

        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    public void suffixOrder() {
        if (this.left != null) {
            this.left.suffixOrder();
        }
        if (this.right != null) {
            this.right.suffixOrder();
        }
        System.out.println(this);
    }

    @Override
    public String toString() {
        return "StudentNode{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
    public StudentNode getLeft() {
        return left;
    }
    public void setLeft(StudentNode left) {
        this.left = left;
    }
    public StudentNode getRight() {
        return right;
    }
    public void setRight(StudentNode right) {
        this.right = right;
    }

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}

```



##### 2, 顺序存储二叉树

* 就是通过数组存储二叉树
* <img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210509134323445.png" alt="image-20210509134323445" style="zoom:50%;" />

```java
package im.bool.a09_tree;

/**
 * @author : 不二
 * @date : 2021/5/9-下午1:47
 * @desc : 数组存储二叉树并实现从数组中按照二叉树的前序中序后序方式读取数据代码重新
 **/
public class a09_02_BinaryTreeToArrDemo_v1 {

    public static void main(String[] args) {

        //int[] arr = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        int[] arr = {1, 3, 6, 8, 10, 14};
        ArrBinaryTreeV1 arrBinaryTree = new ArrBinaryTreeV1(arr);

        System.out.println("数组左序遍历：");
        arrBinaryTree.preOrder();

        System.out.println("数组中序遍历：");
        arrBinaryTree.infixOrder();

        System.out.println("数组后序遍历：");
        arrBinaryTree.suffixOrder();
    }
}

class ArrBinaryTreeV1 {
    private final int[] arr;
    public ArrBinaryTreeV1(int[] arr) {
        this.arr = arr;
    }

    public void preOrder() {
        preOrder01(0);
    }

    // 前序遍历
    public void preOrder01(int n) {

        if (arr != null && arr.length == 0) {
            System.out.println("当前数组为空");
        }

        System.out.println(arr[n]);

        int left = 2 * n + 1;
        int right = 2 * n + 2;
        if (left < arr.length) {
            preOrder01(left);
        }
        if (right < arr.length) {
            preOrder01(right);
        }
    }

    public void infixOrder() {
        infixOrder01(0);
    }

    private void infixOrder01(int n) {
        if (arr.length == 0) {
            System.out.println("无元素");
        }
        int left = 2 * n + 1;
        int right = 2 * n + 2;
        if (left < arr.length) {
            infixOrder01(left);
        }
        System.out.println(arr[n]);
        if (right < arr.length) {
            infixOrder01(right);
        }
    }

    public void suffixOrder() {
        suffixOrder01(0);
    }

    private void suffixOrder01(int n) {
        if (arr.length == 0) {
            System.out.println("无元素");
        }
        int left = 2 * n + 1;
        int right = 2 * n + 2;
        if (left < arr.length) {
            suffixOrder01(left);
        }
        if (right < arr.length) {
            suffixOrder01(right);
        }
        System.out.println(arr[n]);
    }
}
```

##### 3, 线索化二叉树

* n个节点的二叉树链表中含有：==n+1(计算公式:2n-(n-1), 其中2n为n个节点的所有指针数，n-1为n个节点彼此连接的指针数。所有指针减去连接的指针，剩下的就是空指针)==个空指针域。
* 利用二叉链表中的空指针域，存放指向节点在==某种遍历次序==下的前驱和后继节点的指针，这种附加的指针叫做线索
* 加上这种线索的二叉树链表又被称为线索链表，相应的二叉树被称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树又分为：前序线索二叉树，中序线索二叉树，后续线索二叉树。
* 一个节点的前一个节点，称为前驱节点
* 一个节点的后一个节点，称为后继节点



线索化以及线索化后的二叉树的遍历

* 其中二叉树的遍历超级巧妙。需要仔细品味
* 画图更容易理解一些

```java
package im.bool.a09_tree;

/**
 * @author : 不二
 * @date : 2021/5/8-下午8:25
 * @desc : 线索化二叉树代码重写(之前教程看过，不过前面那份代码没写完， 就删除了，这里重新写一份)
 *         我们这里通过中序遍历进行线索化二叉树，也就是先线索化左子树，然后线索化当前节点，最后线索化右子树
 **/
public class a09_03_ThreadBinaryTreeDemo {

    public static void main(String[] args) {

        // 这个是简单的二叉树模型
        /*ThreadStudentBinaryTree binaryTree = new ThreadStudentBinaryTree();
        ThreadStudentNode heroNode01 = new ThreadStudentNode(1, "1");
        ThreadStudentNode heroNode03 = new ThreadStudentNode(3, "3");
        ThreadStudentNode heroNode06 = new ThreadStudentNode(6, "6");
        ThreadStudentNode heroNode08 = new ThreadStudentNode(8, "8");
        ThreadStudentNode heroNode10= new ThreadStudentNode(10, "10");
        ThreadStudentNode heroNode14 = new ThreadStudentNode(14, "14");

        heroNode01.setLeft(heroNode03);
        heroNode01.setRight(heroNode06);

        heroNode03.setLeft(heroNode08);
        heroNode03.setRight(heroNode10);

        heroNode06.setLeft(heroNode14);

        binaryTree.setRootStudent(heroNode01);*/


        // 用复杂一点的二叉树看一下效果
        // 首先构造一个数类并添加节点元素
        ThreadStudentBinaryTree binaryTree = new ThreadStudentBinaryTree();
        ThreadStudentNode heroNode00 = new ThreadStudentNode(0, "1");
        ThreadStudentNode heroNode01 = new ThreadStudentNode(1, "1");
        ThreadStudentNode heroNode02 = new ThreadStudentNode(2, "2");
        ThreadStudentNode heroNode03 = new ThreadStudentNode(3, "3");
        ThreadStudentNode heroNode04 = new ThreadStudentNode(4, "4");
        ThreadStudentNode heroNode05 = new ThreadStudentNode(5, "5");
        ThreadStudentNode heroNode06 = new ThreadStudentNode(6, "6");
        ThreadStudentNode heroNode07 = new ThreadStudentNode(7, "7");
        ThreadStudentNode heroNode08 = new ThreadStudentNode(8, "8");
        ThreadStudentNode heroNode09 = new ThreadStudentNode(9, "9");
        ThreadStudentNode heroNode10 = new ThreadStudentNode(10, "10");
        ThreadStudentNode heroNode11 = new ThreadStudentNode(11, "11");
        ThreadStudentNode heroNode12 = new ThreadStudentNode(12, "12");
        ThreadStudentNode heroNode13 = new ThreadStudentNode(13, "13");
        ThreadStudentNode heroNode14 = new ThreadStudentNode(14, "14");
        /*
                       0
               1                 2
           3       4        5          6
         7  8    9  10    11  12     13  14
         */
        // 设置第一行
        binaryTree.setRootStudent(heroNode00);

        heroNode00.setLeft(heroNode01);
        heroNode00.setRight(heroNode02);

        heroNode01.setLeft(heroNode03);
        heroNode01.setRight(heroNode04);
        heroNode02.setLeft(heroNode05);
        heroNode02.setRight(heroNode06);

        heroNode03.setLeft(heroNode07);
        heroNode03.setRight(heroNode08);
        heroNode04.setLeft(heroNode09);
        heroNode04.setRight(heroNode10);
        heroNode05.setLeft(heroNode11);
        heroNode05.setRight(heroNode12);
        heroNode06.setLeft(heroNode13);
        heroNode06.setRight(heroNode14);

        // 中序先打印一把
        System.out.println("中序打印--");
        binaryTree.infixOrder();


        // 这里调用重载的方法
        binaryTree.threadNodes();
        /*ThreadStudentNode studentNode = heroNode10;
        System.out.println("10号节点的左节点:" + studentNode.getLeft());
        System.out.println("10号节点的右节点:" + studentNode.getRight());*/

        // 使用线索化遍历
        System.out.println("使用线索化方式进行遍历--");
        binaryTree.threadedList();

    }
}

class ThreadStudentBinaryTree {

    ThreadStudentNode rootStudent;

    // 为了实现线索化，需要锁定前节点
    ThreadStudentNode preStudent;

    public ThreadStudentNode getRootStudent() {
        return rootStudent;
    }
    public void setRootStudent(ThreadStudentNode rootStudent) {
        this.rootStudent = rootStudent;
    }

    // 这里直接方法重载即可
    public void threadNodes() {
        threadNodes(rootStudent);
    }

    public void threadedList() {
        ThreadStudentNode node = rootStudent;

        while (node != null) {
            while (node.getLeftType() == 0) {
                node = node.getLeft();
            }
            // 这里暂时不是特别明白。
            System.out.println(node);
            while (node.getRightType() == 1) {
                node = node.getRight();
                System.out.println(node);
            }
            System.out.println("------------又一轮---------");
            node = node.getRight();
        }
    }

    // 二叉树线索化的方法
    // 这里再构造方法里面直接线索化即可
    public void threadNodes(ThreadStudentNode studentNode) {

        // System.out.println(studentNode);

        if (studentNode == null) {
            // System.out.println("节点为null，返回");
            // 当前节点都为null了，那肯定没有左右节点了， 直接返回即可了
            return;
        }

        // 1, 先线索化左子树(调用当前方法即可)
        threadNodes(studentNode.getLeft());

        // 2, 然后线索化当前节点(真正线索化的内容)
        if (studentNode.getLeft() == null) {
            studentNode.setLeft(preStudent);
            studentNode.setLeftType(1);
        }

        // 这里还需要添加个判断：preStudent != null
        // 注意：这里要判断的是前一个的right是null，别判断成当前节点了，吃亏了
        if (preStudent != null && preStudent.getRight() == null) {
            // 这个相当于是这次处理上个节点的right引用。下次再设置本个节点的right引用。
            // 比较巧妙
            preStudent.setRight(studentNode);
            preStudent.setRightType(1);
        }

        preStudent = studentNode;

        // 3, 最后线索化右子树(调用当前方法即可)
        threadNodes(studentNode.getRight());
    }



    // 前序查找
    public ThreadStudentNode preOrderSearch(int id) {
        return this.rootStudent.preOrderSearch(id);
    }
    // 中序查找
    public ThreadStudentNode infixOrderSearch(int id) {
        return this.rootStudent.infixSearch(id);
    }
    // 后序查找
    public ThreadStudentNode suffixOrderSearch(int id) {
        return this.rootStudent.suffixOrderSearch(id);
    }


    // 前序遍历(先遍历主节点，然后遍历左节点，最后遍历右节点)
    public void preOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.preOrder();
        }
    }

    // 中序遍历(先遍历左节点， 然后遍历主节点，最后遍历右节点)
    public void infixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.infixOrder();
        }
    }

    // 后序遍历(先遍历左节点，然后遍历右节点，最后遍历主节点)
    public void suffixOrder() {
        if (rootStudent == null) {
            System.out.println("该树结构无任何元素");
        } else {
            this.rootStudent.suffixOrder();
        }
    }

    public void deleteNode(int i) {

        if (this.rootStudent.getId() == i) {
            System.out.println("删除的是最顶层根节点，无法删除!");
        } else {
            this.rootStudent.deleteNode(i);
        }
    }
}


// 这里是个学生类的二叉树子节点
class ThreadStudentNode {

    private int id;
    private String name;
    private ThreadStudentNode left;
    private ThreadStudentNode right;

    // 这里需要设置两个成员变量， 来确定左右指针的类型是默认的子树，还是线索化设置的引用
    // 这里如果默认是0就是默认的子树， 如果是1则表示是线索化设置的引用
    private int leftType;
    private int rightType;


    public ThreadStudentNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    //删除
    public void deleteNode_v1(int no) {
        //这里和遍历或者查找不一样哈， 因为如果是遍历，是不会返回的
        //这里就只能默认只有一个
        if (this.left != null && this.left.id == no) {
            this.left = null;
            return;
        }
        if (this.right != null && this.right.id == no) {
            this.right = null;
            return;
        }
        if (this.left != null) {
            this.left.deleteNode(no);
        }
        if (this.right != null) {
            this.right.deleteNode(no);
        }
    }
    public void deleteNode(int id) {
        if (this.left != null) {
            if (this.getLeft().getId() == id) {
                this.setLeft(null);
                return;
            }
            this.left.deleteNode(id);
        }

        if (this.right != null) {
            if (this.getRight().getId() == id) {
                this.setRight(null);
                return;
            }
            this.right.deleteNode(id);
        }
    }

    public ThreadStudentNode preOrderSearch(int id) {
        // 1, 先找根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 2, 然后找左节点
        ThreadStudentNode ThreadStudentNode = null;
        if (this.getLeft() != null) {
            ThreadStudentNode = this.getLeft().preOrderSearch(id);
        }
        // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 3, 最后找右节点
        // 如果ThreadStudentNode 为null，说明还未找到
        if (this.getRight() != null) {
            ThreadStudentNode = this.getRight().preOrderSearch(id);
        }
        // 这里为null说明为找到
        return ThreadStudentNode;
    }

    public ThreadStudentNode infixSearch(int id) {

        // 1，先找左节点
        ThreadStudentNode ThreadStudentNode = null;
        if (this.getLeft() != null) {
            ThreadStudentNode = this.getLeft().infixSearch(id);
        }

        // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        // 左节点找到直接返回左节点
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 2，然后找根节点
        // 左节点没找到对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 3，最后找右节点
        // 如果根节点也没找到，找右节点
        // 如果ThreadStudentNode 为null，说明还未找到
        if (this.getRight() != null) {
            ThreadStudentNode = this.getRight().infixSearch(id);
        }
        // 这里为null说明为找到
        return ThreadStudentNode;
    }

    public ThreadStudentNode suffixOrderSearch(int id) {

        // 1，先找左节点
        // 左节点找到直接返回左节点
        ThreadStudentNode ThreadStudentNode = null;
        if (this.getLeft() != null) {
            ThreadStudentNode = this.getLeft().suffixOrderSearch(id);
        }
        // 这里使用ThreadStudentNode进行判断是因为不能直接return this.getLeft().preOrderSearch(id). 否则右侧的判断就没法走了
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 2，然后找右节点
        // 如果左节点没找到，找右节点
        // 如果ThreadStudentNode 为null，说明还未找到
        if (this.getRight() != null) {
            ThreadStudentNode = this.getRight().suffixOrderSearch(id);
        }

        // 如果右侧ok了直接返回就行了
        if (ThreadStudentNode != null) {
            return ThreadStudentNode;
        }

        // 3，最后找根节点
        // 如果左右都没找到， 再对比根节点
        System.out.println("开始找到的id为：" + this.id);
        if (this.id == id) {
            return this;
        }

        // 这里为null说明为找到
        return ThreadStudentNode;
    }

    public void preOrder(){
        // 先打印出当前
        System.out.println(this);

        if (this.left != null) {
            this.left.preOrder();
        }

        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);

        if (this.right != null) {
            this.right.infixOrder();
        }
    }

    public void suffixOrder() {
        if (this.left != null) {
            this.left.suffixOrder();
        }
        if (this.right != null) {
            this.right.suffixOrder();
        }
        System.out.println(this);
    }

    @Override
    public String toString() {
        return "ThreadStudentNode{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
    public ThreadStudentNode getLeft() {
        return left;
    }
    public void setLeft(ThreadStudentNode left) {
        this.left = left;
    }
    public ThreadStudentNode getRight() {
        return right;
    }
    public void setRight(ThreadStudentNode right) {
        this.right = right;
    }

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getLeftType() {
        return leftType;
    }
    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }
    public int getRightType() {
        return rightType;
    }
    public void setRightType(int rightType) {
        this.rightType = rightType;
    }
}
```



##### 4, 树的实际应用

###### 堆排序

* 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它最好，最坏以及平均复杂度均为O(nlogn)，它是不稳定的排序
* 堆是具有以下性质的完全二叉树：
* 大顶堆：每个节点的值大于或者等于其左右孩子节点的值(变成顺序存储二叉树的时候，数组是从大到小的)
* <img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210509193615819.png" alt="image-20210509193615819" style="zoom:50%;" />
* 小顶堆：每个节点的值都小于或等于其左右孩子节点的值(变成顺序存储二叉树的时候，数组是从小到大的)
* <img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210509193701930.png" alt="image-20210509193701930" style="zoom:50%;" />
* 这个太难了，看了4个小时才差不多看明白

```java
package im.bool.a09_tree;

import java.util.Arrays;

/**
 * @author : 不二
 * @date : 2021/5/15-上午10:43
 * @desc : 堆排序代码编写：构建大顶堆或者小顶堆
 **/
public class a09_04_HeapSort {

    // 堆排序
    public static void main(String[] args) {

        int arr[] = {4, 6,122, -5, 34, -111,78, 8, 5, 9};
        heapSort(arr);

    }

    public static void heapSort(int[] arr) {
        System.out.println("堆排序");

        int temp = 0;

        // 首次构建大顶堆，需要从最右下，先同级往左， 然后再往上进行构建
        // 这里i要大于等于0， 因为最上级根节点也需要调整
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }

        System.out.println(Arrays.toString(arr));

        // 首次构建大顶堆之后，先把最大值和数组最后一个元素互换。这样的话， 最大值在末位。
        // 然后调用调整heap的方法，对n-1个元素处理，这样的话，最小值就会排序到最后一级
        // 然后在重复和最后一个元素替换，在重复上述操作即可
        for (int j = arr.length - 1; j > 0; j--) {
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;

            adjustHeap(arr, 0, j);
        }

        System.out.println(Arrays.toString(arr));

    }

    /**
     * 注意：这个方法并不是直接把树直接变成大顶堆或者小顶堆, 而是把给定的树变成最小值挪到下面。最大值挪到当前根节点(最大值不一定会挪到最上面)
     *      所以：第一次调节的时候， 需要从右往左，从下往上，依次调用该方法，这样的话， 就可以变成大顶堆了。
     *      然后后续的把最值和最后一位数据交换后， 再对n-1个数据进行调整(只需要调整最上一个根节点即可，因为这个时候只有最上面一个值不符合大顶堆，
     *      下面的值会依次往上走，而根节点的这个值会交换到最下一级
     *      好吧， 估计再重新看这段话的时候估计也看不明白)
     * @param arr 待调整的数组(按照二叉树的方式进行处理的)
     * @param i 根节点的位置
     * @param length 对元素多少个数据进行调整。
     *               因为顶堆建立之后， 会把最值放在边缘，
     *               这样的话，后续再做顶堆的时候，需要排序的数据就少了1个，依次做顶堆，然后放到后面， 这样数据就有序了
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];

        // 相当于左左叶子节点依次往下走， 会把大值往上走一级，最小值则直接放在最后
        for (int k = 2 * i + 1; k < length; k = 2 * k + 1) {
            // k+1 < length防止数据越界？
            if ( k+1 < length && arr[k] < arr[k + 1]) {
                // 说明叶子节点右侧的大于左侧的
                // k+1就是把当前叶子节点从左侧叶子节点变成右侧叶子节点
                k++;
            }

            if (arr[k] > temp) {
                // 说明叶子节点大于根节点
                // 那么就把叶子节点的最大值往上走一级
                arr[i] = arr[k];
                // 这个是从k处接着往下走
                i = k;
            } else {
                // 说明两个叶子节点都不大于根节点，那么就可以直接退出了
                break;
            }

            // 如果走完之后， 说明当前i处就是把最小值放置的位置
            arr[i] = temp;
            // 至此，最大值依次往上走， 最小值被挪至最后一行(最后一级)
        }
    }
}
```



##### 5, Huffman Tree(赫夫曼树)

* 给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度==wpl==:weighted path length达到最小，则称为最优二叉树，即是Huffman Tree
* 赫夫曼树是带权路径最短的树，权值较大的节点离根较近

###### 构建HuffmanTree的步骤

1. 把从小到大进行排序，每个元素是一个节点，每个节点看作是一个最简单的二叉树
2. 取出跟节点权值最小的两个二叉树组成一棵新的二叉树，该新二叉树根节点的权值是前面两棵二叉树根节点权值加和
3. 再将这棵新的二叉树，以根节点权值大小再次排序。
4. 不断重复1，2，3步骤，直到数列中， 所有的数据都被处理，最后得到一棵二叉树

```java
package im.bool.a10_huffmanTree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author : 不二
 * @date : 2021/5/15-下午7:30
 * @desc : huffman树构建
 **/
public class a10_01_HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};
        Node node = constructHuffmanTree(arr);
        node.preOrder();
    }

    // 给定数组，构建huffman树
    public static Node constructHuffmanTree(int[] arr) {
        // 1，先构造成Node数组
        List<Node> nodeList = new ArrayList<>();
        for (int i : arr) {
            nodeList.add(new Node(i));
        }

        // 2, 根据方法直接排序
        // 最后会剩下最上级root节点
        while (nodeList.size() > 1) {
            Collections.sort(nodeList);
            // System.out.println("排序后数组为：" + nodeList.toString());

            // 3, 先取出根节点最小的两个最简树(其实就是从小到大排序后的前面两个Node)
            Node left = nodeList.get(0);
            Node right = nodeList.get(1);

            Node theRoot = new Node(left.value + right.value);
            theRoot.left = left;
            theRoot.right = right;

            // 因为这两个节点已经关联上二叉树，所以可以从数组中去掉了
            nodeList.remove(left);
            nodeList.remove(right);
            nodeList.add(theRoot);
        }

        Node finalRoot = nodeList.get(0);
        return finalRoot;
    }
}

// 节点类,这里避免代码太多， 就不添加不必要的方法了
// 因为需要排序，需要实现Comparable接口
class Node implements Comparable<Node> {
    int value;
    Node left;
    Node right;

    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" + "value=" + value  + '}';
    }

    @Override
    public int compareTo(Node o) {
        // this.value写在前面表示从小到大排列
        return this.value - o.value;
    }
}
```



###### Huffman Code(Huffman编码)

* 前缀编码

![image-20210515195159292](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210515195159292.png)

* 通过Huffman编码实现数据的压缩和解压缩
* 代码参考：im.bool.a11_huffmanCode



##### 6, binarySortTree(BST:二叉排序树)

<img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210522104947114.png" alt="image-20210522104947114" style="zoom:50%;" />



* 对于二叉排序树的任何一个非叶子节点， 要求：左子节点的值比当前节点的值小。右子节点的值比当前节点的值大
*  特别说明：如果有相同的值，可以将该节点放在左子节点或者右子节点，按照规则存放即可
* 二叉排序树特性：中序遍历的结果刚好是从小到大打印
* 如下代码显示了二叉排序树的创建，新增，删除节点等

```java
package im.bool.a12_binarySortTree;

import java.util.ArrayList;
import java.util.List;

/**
 * @author : 不二
 * @date : 2021/5/16-下午2:29
 * @desc : 二叉排序树demo演示
 *  用二叉排序树进行排序的话， 80万数据， 快速排序大概150s，二叉排序树大概630s，二叉排序树比冒泡要好的多，
 **/
public class a12_BinarySortTreeDemo {
    public static void main(String[] args) {

        // 这不就可以直接当作排序来用了吗
        // int[] arr = {7, 3, 10, 12, 5, 1, 9, -1, 2, 3, 7, 6};
        // 80000万这个量级的数据好像不行了，跑不动了
        /*int count = 80000000;
        int[] nums = new int[count];
        for (int i = 0; i < count; i++) {
            nums[i] = (int) (Math.random() * count);
        }

        long startTime = System.currentTimeMillis();
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i : nums) {
            binarySortTree.add(new Node(i));
        }

        *//*System.out.println("前序遍历：");
        binarySortTree.preOrder();*//*

        // 二叉排序树的中序排列刚好是升序排列
        System.out.println("中序遍历(升序)：");
        // binarySortTree.infixOrder();
        // int[] result = new int[count];
        List<Integer> result = new ArrayList<>();
        binarySortTree.infixOrderSort(result);

        long endTime = System.currentTimeMillis();
        long duration = (endTime - startTime);
        System.out.println("排序耗时---" + duration);*/

        // int[] arr = {7, 3, 10, 12, 5, 1, 9, -1, 2, 3, 7, 6};
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i : arr) {
            binarySortTree.add(new Node(i));
        }
        // 二叉排序树的中序排列刚好是升序排列
        System.out.println("中序遍历(升序)：");
        binarySortTree.infixOrder();


        binarySortTree.delNode(2);
        binarySortTree.delNode(5);
        binarySortTree.delNode(9);
        binarySortTree.delNode(12);
        binarySortTree.delNode(7);
        binarySortTree.delNode(3);
        binarySortTree.delNode(10);

        System.out.println();
        System.out.println("删除数据后中序遍历(升序)：");
        binarySortTree.infixOrder();

        System.out.println();
        System.out.println("根节点是：" + binarySortTree.printRoot());
    }
}


class BinarySortTree {
    private Node root;

    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    // 删除一个节点
    public void delNode(int value) {
        if (root == null) {
            return;
        } else {
            //删除一个节点:
            // 1，先找到该节点
            Node node = search(value);
            if (node == null) {
                // 说明没有该节点可以直接返回
                return;
            }

            // 先优化一点：因为已经找到节点， 但是如果整个二叉排序树只有一个节点，那么删除的必定是主根节点
            // 直接把根节点设置为null即可
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }

            // 2, 再找到该节点的父节点
            Node parentNode = searchParent(value);

            // 3，如果删除的节点node是叶子节点：
            // 先判断节点是左子节点还是右子节点，然后直接设置为null即可
            if (node.left == null && node.right == null) {
                if (parentNode.left != null && parentNode.left.value == node.value) {
                    parentNode.left = null;
                } else if (parentNode.right != null && parentNode.right.value == node.value) {
                    parentNode.right = null;
                }
            }
            // 4, 先删除非叶子节点：先删除有两棵子树的情况：
            else if (node.left != null && node.right != null) {
                // 这种情况下，需要从删除节点的右子节点树中找到最小的值，并把最小值赋予node上(node的数据就被删除了，而且赋值后依然满足二叉排序树规则)
                // 如果不想从右子树找最小值，这里其实也可以从左子树找到最大值然后赋值到node上也一样
                int min = delRightTreeMin(node.right);
                // 搞定！
                node.value = min;
            }
            // 5, 最后只剩一种情况：就是非叶子节点， 但是只有一棵子树
            else {
                // 这里有一个问题：如果删除一个只有一个叶子节点的根节点，那么因为根节点没有parentNode了，那么就会报错
                /*if (node.left != null) {
                    // 说明有的那棵子树是左子树
                    if (parentNode.left.value == node.value) {
                        parentNode.left = node.left;
                    } else {
                        parentNode.right = node.left;
                    }
                } else {
                    // 说明是右子树
                    if (parentNode.left.value == node.value) {
                        parentNode.left = node.right;
                    } else {
                        parentNode.right = node.right;
                    }
                }*/

                if (node.left != null) {
                    if (parentNode != null) {
                        // 说明有的那棵子树是左子树
                        if (parentNode.left.value == node.value) {
                            parentNode.left = node.left;
                        } else {
                            parentNode.right = node.left;
                        }
                    } else {
                        root = node.left;
                    }
                } else {
                    if (parentNode != null) {
                        // 说明是右子树
                        if (parentNode.left.value == node.value) {
                            parentNode.left = node.right;
                        } else {
                            parentNode.right = node.right;
                        }
                    } else {
                        root = node.right;
                    }
                }
            }
        }
    }

    /**
     * 返回以node为根节点的二叉排序树最小节点的值
     * 并在该二叉排序树中删除最小的节点
     * @param node
     * @return
     */
    public int delRightTreeMin(Node node) {
        Node target = node;
        while (target.left != null) {
            target = target.left;
        }
        // 因为这个值肯定是最后的叶子节点，所以可以直接调用delNode方法
        delNode(target.value);
        return target.value;
    }

    public Node search(int value) {
        if (root == null) {
            return null;
        } else {
            return this.root.search(value);
        }
    }

    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return this.root.searchParent(value);
        }
    }


    public void preOrder() {
        if (root == null) {
            System.out.println("为null");
            return;
        }
        this.root.preOrder();
    }

    // 二叉排序树的中序排列刚好是升序排列
    public void infixOrder() {
        if (root == null) {
            System.out.println("为null");
            return;
        }
        this.root.infixOrder();
    }

    public void infixOrderSort(List<Integer> result) {
        if (root == null) {
            System.out.println("为null");
            return;
        }
        this.root.infixOrderSort(result);
    }

    public Node printRoot() {
        return this.root;
    }
}


class Node {

    int value;
    Node left;
    Node right;

    // 删除节点需要先查找这个节点
    public Node search(int value) {
        if (value == this.value) {
            return this;
        } else if (value < this.value) {
            // 如果调用左节点， 那么左节点必然不为null，否则会报错
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            // 如果调用右节点， 那么右节点必然不为null，否则会报错
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    public Node searchParent(int value) {
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if (value >= this.value && this.right != null) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }
    }


    // 添加节点方法
    public void add(Node node) {
        if (node == null) {
            System.out.println("被添加节点为null");
            return;
        }
        if (node.value < this.value) {
            if (this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }
    }

    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.print(this + " => ");
        if (this.right != null) {
            this.right.infixOrder();
        }
    }


    public void preOrder() {
        System.out.print(this + " => ");
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" + "value=" + value + '}';
    }

    public void infixOrderSort(List<Integer> result) {
        if (this.left != null) {
            this.left.infixOrderSort(result);
        }
        // System.out.print(this + " => ");
        result.add(this.value);
        if (this.right != null) {
            this.right.infixOrderSort(result);
        }
    }
}
```



##### 7, AVL树：平衡二叉树

* 又叫Self-Balancing Binary Search Tree

<img src="https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210522105107461.png" alt="image-20210522105107461" style="zoom:50%;" />



* 它是一棵空树或者它的左右两个子树的高度的绝对值不超过1
* 并且左右两棵子树都是一棵平衡二叉树
* 平衡二叉树常用的实现形式：==红黑树==，==AVL(算法)==，==替罪羊树==，==Treap==，==伸展树==
* 

###### 树旋转(左旋转/右旋转)

* 看代码

```java
package im.bool.a13_avlTree;

import java.util.List;

/**
 * @author : 不二
 * @date : 2021/5/22-上午10:59
 * @desc :  平衡二叉树演示
 **/
public class a13_AvlTreeDemo {
    public static void main(String[] args) {
        // int[] arr = {4, 3, 6, 5, 7, 8};
        // int[] arr = {10, 12, 8, 9, 7, 6};
        int[] arr = {10, 11, 7, 6, 8, 9};

        AVLTree avlTree = new AVLTree();
        for (int i : arr) {
            avlTree.add(new Node(i));
        }

        System.out.println("中序遍历：");
        avlTree.infixOrder();

        System.out.println("处理前：");
        System.out.println("树的高度为:" + avlTree.root().height());
        System.out.println("左子树的高度为:" + avlTree.root().left.height());
        System.out.println("右子树的高度为:" + avlTree.root().right.height());


        System.out.println("root:" + avlTree.root());
        System.out.println("root.left:" + avlTree.root().left);
        System.out.println("root.right:" + avlTree.root().right);
    }
}


class AVLTree {
    private Node root;

    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    // 删除一个节点
    public void delNode(int value) {
        if (root == null) {
            return;
        } else {
            //删除一个节点:
            // 1，先找到该节点
            Node node = search(value);
            if (node == null) {
                // 说明没有该节点可以直接返回
                return;
            }

            // 先优化一点：因为已经找到节点， 但是如果整个二叉排序树只有一个节点，那么删除的必定是主根节点
            // 直接把根节点设置为null即可
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }

            // 2, 再找到该节点的父节点
            Node parentNode = searchParent(value);

            // 3，如果删除的节点node是叶子节点：
            // 先判断节点是左子节点还是右子节点，然后直接设置为null即可
            if (node.left == null && node.right == null) {
                if (parentNode.left != null && parentNode.left.value == node.value) {
                    parentNode.left = null;
                } else if (parentNode.right != null && parentNode.right.value == node.value) {
                    parentNode.right = null;
                }
            }
            // 4, 先删除非叶子节点：先删除有两棵子树的情况：
            else if (node.left != null && node.right != null) {
                // 这种情况下，需要从删除节点的右子节点树中找到最小的值，并把最小值赋予node上(node的数据就被删除了，而且赋值后依然满足二叉排序树规则)
                // 如果不想从右子树找最小值，这里其实也可以从左子树找到最大值然后赋值到node上也一样
                int min = delRightTreeMin(node.right);
                // 搞定！
                node.value = min;
            }
            // 5, 最后只剩一种情况：就是非叶子节点， 但是只有一棵子树
            else {
                // 这里有一个问题：如果删除一个只有一个叶子节点的根节点，那么因为根节点没有parentNode了，那么就会报错
                /*if (node.left != null) {
                    // 说明有的那棵子树是左子树
                    if (parentNode.left.value == node.value) {
                        parentNode.left = node.left;
                    } else {
                        parentNode.right = node.left;
                    }
                } else {
                    // 说明是右子树
                    if (parentNode.left.value == node.value) {
                        parentNode.left = node.right;
                    } else {
                        parentNode.right = node.right;
                    }
                }*/

                if (node.left != null) {
                    if (parentNode != null) {
                        // 说明有的那棵子树是左子树
                        if (parentNode.left.value == node.value) {
                            parentNode.left = node.left;
                        } else {
                            parentNode.right = node.left;
                        }
                    } else {
                        root = node.left;
                    }
                } else {
                    if (parentNode != null) {
                        // 说明是右子树
                        if (parentNode.left.value == node.value) {
                            parentNode.left = node.right;
                        } else {
                            parentNode.right = node.right;
                        }
                    } else {
                        root = node.right;
                    }
                }
            }
        }
    }

    /**
     * 返回以node为根节点的二叉排序树最小节点的值
     * 并在该二叉排序树中删除最小的节点
     * @param node
     * @return
     */
    public int delRightTreeMin(Node node) {
        Node target = node;
        while (target.left != null) {
            target = target.left;
        }
        // 因为这个值肯定是最后的叶子节点，所以可以直接调用delNode方法
        delNode(target.value);
        return target.value;
    }

    public Node search(int value) {
        if (root == null) {
            return null;
        } else {
            return this.root.search(value);
        }
    }

    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return this.root.searchParent(value);
        }
    }


    public void preOrder() {
        if (root == null) {
            System.out.println("为null");
            return;
        }
        this.root.preOrder();
    }

    // 二叉排序树的中序排列刚好是升序排列
    public void infixOrder() {
        if (root == null) {
            System.out.println("为null");
            return;
        }
        this.root.infixOrder();
    }

    public void infixOrderSort(List<Integer> result) {
        if (root == null) {
            System.out.println("为null");
            return;
        }
        this.root.infixOrderSort(result);
    }

    public Node root() {
        return this.root;
    }
}


class Node {

    int value;
    Node left;
    Node right;

    /**
     * 对当前节点进行左旋转
     */
    private void leftRotate() {

        // 1，以当前节点的值创建新的节点
        // 2, 把新节点的左子树设置成当前节点的左子树
        // 3，把新节点的右子树设置成当前节点右子树的左子树
        // 4，把当前节点(非新创建的节点哈)的值换成右子节点的值
        // 5，把当前节点的左子树设置成新节点
        // 6，把当前节点的右子树设置成右子树的右子树

        // 1
        Node newNode = new Node(this.value);
        // 2
        newNode.left = this.left;
        // 3
        newNode.right = this.right.left;
        // 4
        this.value = this.right.value;
        // 5
        this.left = newNode;
        // 6
        this.right = this.right.right;

    }

    /**
     * 对当前节点进行右旋转
     */
    private void rightRotate() {
        // 1，以当前节点的值创建新的节点
        // 2, 把新节点的右子树设置成当前节点的右子树
        // 3，把新节点的左子树设置成当前节点左子树的右子树
        // 4，把当前节点(非新创建的节点哈)的值换成左子节点的值
        // 5，把当前节点的右子树设置成新节点
        // 6，把当前节点的左子树设置成左子树的左子树

        // 1
        Node newNode = new Node(value);
        // 2
        newNode.right = this.right;
        // 3
        newNode.left = this.left.right;
        // 4
        this.value = this.left.value;
        // 5
        this.right = newNode;
        // 6
        this.left = this.left.left;
    }



    public int leftHeight() {
        if (left == null) {
            return 0;
        }
        return left.height();
    }

    public int rightHeight() {
        if (right == null) {
            return 0;
        }
        return right.height();
    }

    // 返回以该节点作为根节点的树的高度
    public int height() {
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
    }



    // 删除节点需要先查找这个节点
    public Node search(int value) {
        if (value == this.value) {
            return this;
        } else if (value < this.value) {
            // 如果调用左节点， 那么左节点必然不为null，否则会报错
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            // 如果调用右节点， 那么右节点必然不为null，否则会报错
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    public Node searchParent(int value) {
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if (value >= this.value && this.right != null) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }
    }


    // 添加节点方法
    public void add(Node node) {
        if (node == null) {
            System.out.println("被添加节点为null");
            return;
        }
        if (node.value < this.value) {
            if (this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }
        }

        // 当节点添加完毕后，如果发现两边不平衡，需要进行旋转
        // 如果右子树比左子树高，需要左旋转
        if (rightHeight() - leftHeight() > 1) {
            // 注意：如果右子树里面：右子树的左子树比右子树的右子树高，那么需要先对右子树进行右旋转
            if (right != null && right.leftHeight() - right.rightHeight() > 0) {
                this.left.rightRotate();
            }

            leftRotate();

            // 这里平衡了就必须直接返回
            return;
        }
        // 如果左子树比右子树高， 需要右旋转
        if (leftHeight() - rightHeight() > 1) {

            // 注意：如果左子树里面：左子树的右子树比左子树的左子树高，那么需要先对左子树进行左旋转
            if (left != null && left.rightHeight() - left.leftHeight() > 0) {
                this.left.leftRotate();
            }

            rightRotate();
        }

    }

    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.print(this + " => ");
        if (this.right != null) {
            this.right.infixOrder();
        }
    }


    public void preOrder() {
        System.out.print(this + " => ");
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" + "value=" + value + '}';
    }

    public void infixOrderSort(List<Integer> result) {
        if (this.left != null) {
            this.left.infixOrderSort(result);
        }
        // System.out.print(this + " => ");
        result.add(this.value);
        if (this.right != null) {
            this.right.infixOrderSort(result);
        }
    }
}
```

#####  2-3树

* 2-3树是最简单的b树结构
* 2-3树的所有叶子节点都在同一层(B树的共同特点)
* 有两个节点的节点叫做二节点， 二节点要么没有子节点，要么有两个子节点
* 有三个节点的节点叫做三节点， 三节点要么没有子节点， 要么有三个子节点
* 2-3树是有二节点和三节点组成的树





#### 2.4, 图结构

```java
package im.bool.a14_graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Map;

/**
 * @author : 不二
 * @date : 2021/5/22-下午3:17
 * @desc : 图的代码演示
 **/
public class a14_GraphDemo {
    public static void main(String[] args) {
        Graph graph = new Graph(8);
        // String[] vertex = {"A", "B", "C", "D", "E"};
         String[] vertex = {"1", "2", "3", "4", "5", "6", "7", "8"};
        // 先插入点
        for (String s : vertex) {
            graph.insertVertex(s);
        }

        // 添加边, A-B(0,1), A-C(0,2), B-C(1,2), B-D(1,3), B-E(1,4)
        // A 0
        // B 1
        // C 2
        // D 3
        // E 4
        /*graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);*/
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);
        graph.insertEdge(3, 7, 1);
        graph.insertEdge(4, 7, 1);
        graph.insertEdge(2, 5, 1);
        graph.insertEdge(2, 6, 1);
        graph.insertEdge(5, 6, 1);

        // 显示邻接矩阵
        graph.showGraph();

        System.out.println("dfs深度遍历");
        graph.depthFirstSearch();

        System.out.println();
        System.out.println("bfs深度遍历");
        graph.broadFirstSearch();


    }
}

class Graph {

    // 这里在额外添加一个map，保存vertext和其索引的关系
    // private Map<String, Integer> vertexMap;

    // 存储定点(我们这里认为每个点是一个字符串，也就是点的名字)
    private ArrayList<String> vertexList;

    // 存储边(连接矩阵)
    private int[][] edges;
    // 一共有多少边
    private int numOfEdges;

    private boolean[] isVisited;

    public Graph(int n) {
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        isVisited = new boolean[n];
    }


    /**
     *
     * @param index：给定定点位置，获取该定点最临近的临接点(远近是按照点的插入顺序来确定的，早插入的就比较近(其实就是索引比较小的))
     * @return 返回-1代表没有临接点
     */
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    /**
     *
     * @param v1: 该表点的位置X坐标
     * @param v2：代表当前点Y坐标(找下一个， y+1就是下一个)
     * @return
     */
    public int getNextNeighbor(int v1, int v2) {
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if (edges[v1][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    /**
     * 图的深度优先遍历(Depth First Search)
     *
     * @param
     * i: 第一次传0， 然后后续根据遍历进行逐步往后遍历
     * 这里有个潜在的内容：如果有一个点被加入， 那么该点一定和其他任何点有关系，要不然加到图中就咩有意义了
     */
    private void depthFirstSearch(boolean[] isVisited, int i) {
        // 拿到节点， 先打印出结果
        System.out.print(getVertexValueByIndex(i) + " ===> ");
        // 将该节点设置为已访问
        isVisited[i] = true;

        // 根据给定的位置，获取该位置点上的下一个点
        int w = getFirstNeighbor(i);
        //  说明该点有临接点
        while (w != -1) {
            // 说明找到临接点，而且该点并未被访问过
            if (!isVisited[w]) {
                depthFirstSearch(isVisited, w);
            }

            // 如果找到了临接点， 但是该点被访问过了，那么需要找下一个临接点
            w = getNextNeighbor(i, w);
        }

        // 说明当前点的所有对应位置均未找到未访问过的临接点
        // 这个时候需要往上回溯找上面一个点的后续坐标(因为这里是给定i的，所以这个回溯需要放在另外的方法中:depthFirstSearch)
    }

    // 方法重载
    public void depthFirstSearch() {
        // 使用前先初始化以免被其他干扰
        isVisited = new boolean[getNumofVertex()];
        for (int i = 0; i < getNumofVertex(); i++) {
            if (!isVisited[i]) {
                depthFirstSearch(isVisited, i);
            }
        }
    }


    /**
     * 图的广度优先遍历 (Broad First Search: BFS广度优先遍历)
     *
     * @param
     */
    private void broadFirstSearch(boolean[] isFirstVisited, int i) {
        // 表示队列头节点的下表
        int u;
        // 表示队列临接节点
        int w;

        LinkedList queue = new LinkedList();
        // 进来之后先打印出头节点
        System.out.print(getVertexValueByIndex(i) + " ===> ");

        isVisited[i] = true;
        queue.addLast(i);

        // 当队列中不为空的时候
        while (!queue.isEmpty()) {
            // 把刚才添加进去的取出来，也就是头节点
            u = (int) queue.removeFirst();
            w = getFirstNeighbor(u);
            while (w != -1) {
                if (!isVisited[w]) {
                    System.out.print(getVertexValueByIndex(w) + " ===> ");
                    isVisited[w] = true;
                    queue.addLast(w);
                }

                // 广度查询
                w = getNextNeighbor(u, w);
            }
        }
    }
    public void broadFirstSearch() {

        // 使用前先初始化以免被其他干扰
        isVisited = new boolean[getNumofVertex()];

        for (int i = 0; i < getNumofVertex(); i++) {
            if (!isVisited[i]) {
                broadFirstSearch(isVisited, i);
            }
        }
    }


    // 插入点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

//    public void insertVertex


    /**
     * 添加边
     * @param v1：这个是边的第一个定点的位置下标
     * @param v2：这个是边的第二个定点的位置下标
     * @param weihgt：这个表示边的属性，我们这里用1表示该表是通的， 0表示该边不通
     */
    public void insertEdge(int v1, int v2, int weihgt) {
        edges[v1][v2] = weihgt;
        // 因为我们这个做的是无向边，所以反向也要设置上
        edges[v2][v1] = weihgt;
        //插入一条边，这里记录下边的条数
        numOfEdges++;
    }

    /**
     * 根据索引获取对应的的点
     * @param i
     * @return
     */
    public String getVertexValueByIndex(int i) {
        return vertexList.get(i);
    }

    /**
     * 根据两个定点的下表获取该两个点的连接情况(权重)
     * @param v1
     * @param v2
     * @return
     */
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    public void showGraph() {
        for (int i = 0; i < edges.length; i++) {
            int[] link = edges[i];
            System.out.println(Arrays.toString(link));
        }
    }

    /**
     * 返回定点的个数
     * @return
     */
    public int getNumofVertex() {
        return vertexList.size();
    }

    /**
     * 返回边的条数
     */
    public int getNumOfEdges() {
        return numOfEdges;
    }
}

```



#### 2.5, 广义表